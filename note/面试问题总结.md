# 一、C#部分

## **1、struct和class的区别**

在c#中struct和class都可以代表一种数据类型，但是也有很多区别

①类型不同，struct是值类型，创建实例时变量直接存储值，而class是引用类型，创建实例时存储的是对象的引用而不是对象本身

②内存分配不同，struct由于是值类型所以在栈上分配内存，而class由于是引用类型所以在堆上分配内存。由于堆上的内存在过多时会进行GC，所以使用class会产生更多的开销

③默认值不同，class的默认值可以为null，而struct不可以

④继承方式不同，class支持继承和多态，而struct不支持。

综上所述class更为灵活，虽然开销更大但是在内部可以写复杂的逻辑，而且支持继承和多态，所以在数据较大并且复杂的时候，应当使用class，当数据较小并且简单时使用struct

## **2、C#中堆和栈的区别**

堆和栈是两种不同的内存分配方式，栈在编译期间就已经分配好的内存空间，存储着函数的参数、局部变量返回值等，并且存在着先进后出，后进先出的顺序。而堆是程序运行期间动态分配的内存空间，其内部是无序的并且空间更大，引用类型被声明时都会存储在堆中，并将其在堆中的地址存储在栈上。

## **3、abstract class和interface有什么区别**

abstract class和interface在功能上没有任何区别，都需要让继承抽象类或者接口的对象实现其内部成员，他们的区别主要在设计思路上，抽象类代表的是同一类所具有的共同功能，如动物是一个抽象类，而其子类的人类、猫、狗、鱼等等都具有吃饭、睡觉等共同特征。而接口代表的只是一种功能，继承同一接口的成员即使不是同一种类也可以具有同样的功能，如汽车可以移动，人可以移动，所以继承了同一接口的成员只能说他们具备此接口的功能而不是同一种类。

## **4、C#中委托是什么？事件是不是一种委托？有什么不同？**

委托是一种类，定义了方法的类型，表示了对签名相同（即参数列表和返回值相同）的方法的引用。可以通过使用委托来封装一个方法，然后将其作为参数传递给其他方法或者赋值给一个变量，这样就可以在运行时动态的调用不同的方法。

事件是一种特殊的委托，用于在程序的不同部分之间传递消息或者通知

事件和委托之间的主要区别在于事件提供了更多的封装。当定义一个事件时，只能通过 `+=` 和 `-=` 运算符来添加或删除事件处理程序。这意味着我们不能直接调用事件，也不能直接修改事件的调用列表。这样，事件的发布者可以更好地控制事件的调用。

## **5、C#实现多态的过程中overload重载和override重写的区别**

重载和重写具有本质性区别，重载只是说具有相同的方法名，但参数的类型、顺序、数量不同，当调用时会根据传入的参数的类型、顺序和数量来调用相应的方法。参数的重写是指将一个方法在派生类中重新定义其逻辑

## **6、ref和out有什么区别**

在c#中，ref和out都是用来传递方法参数的关键字，可以使我们在方法内部修改参数的值并将修改后的值传回（也就是使值类型具有类似引用类型的效果），但两者之间也存在着区别

使用ref关键字之前必须初始化这个参数，然后在内部对参数进行修改，修改后的值会返回出来。而使用out关键字之前不需要对这个参数进行初始化，但是在方法内部必须对这个参数赋值，修改后的参数同样也会返回出来。

ref和out都可以使值类型变量达到类似引用类型变量的效果，但是ref有进有出，out只出不进

## **7、字符串string str=null和string str=""和string str=string.Empty的区别是什么**

string str=""和string str=string.Empty没有任何区别，都表示在托管堆中开辟一块没有任何内容的区域然后将这块区域的地址赋值给str，都表示一个长度为0的字符串，而string str=null表示没有任何的引用对象

## **8、什么是扩展方法**

在c#中定义扩展方法时，可以为现有类添加新的方法而不需要修改原始类的定义或创建子类，这对于在无法访问原始类的源代码时添加新功能非常有用（但也应尽量避免使用，因为会使代码难以理解和维护）

使用扩展方法时必须满足两个条件①扩展方法必须定义在静态类中②扩展方法的第一个参数指定要扩展的类型，并且要用this关键字标识

例：

```c#
public static class MyClassExtensions
{
    public static void MyMethod(this MyClass myClass,int x)
      {
         //这里实现MyMethod的逻辑    
      }
}
MyClass myObject=new MyClass();
myObject.MyMethod(10);
```

## **9、as和is的区别**

is关键字用于类型之间的检查，如果检查的两个类型一致那么返回true否则返回false，as关键字用于类型之间的转换，如果转换成功则返回转换后的对象，否则返回null

## **10、string和stringBuilder的区别，两者性能如何**

string和stringBuilder都表示字符串，但是有显著区别，当一个string类型的变量生成时无法修改除非重新生成一个string类型的字符串，而stringBuilder生成的字符串可以进行插入、删除、修改。对于简单的字符串连接操作，在性能上stringBuilder不一定总是优于string，因为stringBuilder对象的创建也会浪费性能，所以在字符串连接较少的情况下滥用stringBuilder会导致性能的浪费而非节约，只有在大量且无法预知次数的字符串操作才考虑stringBuilder的使用

## **11、面向对象的三大特点，请简要叙述**

 面向对象的三大特点是封装、继承、多态，面向对象的思想是万物皆对象，并将每个对象划分为不同的属性和功能，当对象具有其所需要的所有属性和功能时，就成功创建了一个对象，而如果每有一个对象就要重新给其添加方法属性又过于臃肿复杂，所以引入了继承的概念，即基类确定好这一类对象所具备的共同特点，子类只需继承即可具备这些属性和功能，而在创建一个对象时需要遵循高内聚低耦合的特点，减少各个模块之间的关联性，所以引入了封装，将对象所具有的功能封装在一个特定的方法内，不仅可以减少程序的耦合性并且可以防止外部随意获取、修改其中的内容。多态是指不同的对象以自己独有的方式响应受到的消息，可以通过抽象方法或者接口实现，对于同一类的对象，其具备的功能可能有所不同，所在可以在每个派生类中重写继承来的功能以实现相同的消息不同的反应

## **12、什么是拆装箱，简述其弊端**

在c#中所有类型都继承于object这个最基类，所以所有类型都可以向上转型为object类，当实现某一功能不确定需要传入什么类型的参数时，可以使用object代替，如果传入的类型是值类型时，会发生装箱操作，然后将转换后的object类型在转换回值类型时，会发生拆箱操作，但是在装箱和拆箱的过程会带来性能的开销，这是拆装箱的弊端之一，第二就是存在类型不安全的问题，因为编译器无法在编译期间判断转换的类型和原有类型是否兼容，所以在运行期间可能会异常报错。

为避免这两种弊端，c#提供了一种更好的解决方式，即泛型，因为在泛型中，类型参数在编译期间就确定了，所以编译器可以在编译期间检查类型的安全性，并且泛型还能够提高代码的重用性和性能，所以在能使用泛型解决问题的情况下应该尽量避免拆装箱。

## **13、拆装箱的内存原理**

```
int i=123;
object o=i;
int j=(int)o;
```

上面的代码是一个简单的拆装箱过程，在这个过程中首先执行int i=123,由于i是值类型，所以会在栈中开辟一块内存存储123，然后执行第二段代码，object o=i；由于i是值类型，object是引用类型，所以会先将i的数据拷贝一份，然后在堆中开辟一块内存将拷贝的数据写入堆中，同时将这块内存区域的引用传递给对象o。接着执行第三段代码，由于j是值类型，o是引用类型，所以需要进行强制性转换，此时会将堆中存储的数据拷贝一份，然后拷贝进栈中。

## **14、常规容器和泛型容器有什么区别**

①类型安全性：泛型容器是类型安全的，它在编译器就能够检测到类型错误，因此可以避免运行时出现类型不匹配的错误。而常规容器由于是以object类型作为存储元素的元素，所以可以存储任意类型的数据，这就无法避免的存在数据类型不安全的问题

②性能：泛型容器的性能更好，因为泛型容器可以直接存储值类型数据，而常规容器则需要将值类型装箱未引用类型，导致额外的性能开销

③使用方式：泛型容器需要在创建对象时指定要存储的数据类型，这样能够在编译期检查类型错误，而常规容器不需要。

常规容器：

- ArrayList：动态数组，可以存储任何类型的对象。
- Hashtable：基于哈希表的字典，可以存储键值对。
- Queue：先进先出的队列，可以存储任何类型的对象。
- Stack：后进先出的栈，可以存储任何类型的对象。

泛型容器：

- List：动态数组，可以存储特定类型的对象。
    
- Dictionary<TKey, TValue>：基于哈希表的字典，可以存储键值对。
    
- Queue：先进先出的队列，可以存储特定类型的对象。
    
- Stack：后进先出的栈，可以存储特定类型的对象
    ## **15、请简述GC产生的原因，并描述如何避免**
    
    GC（垃圾回收）是 C# 中用于自动管理内存的机制。它负责释放不再使用的对象所占用的内存，从而避免内存泄漏和内存碎片。
    
    GC 的产生原因是为了简化内存管理。在没有 GC 的语言中，程序员需要手动分配和释放内存。这不仅增加了编程的复杂性，而且容易出错。如果程序员忘记释放内存，就会导致内存泄漏；如果程序员错误地释放了内存，就会导致程序崩溃。GC 通过自动管理内存，解决了这些问题。
    
    尽管 GC 可以自动管理内存，但它并不是万能的。有时候，GC 会对程序性能产生负面影响。为了避免这种情况，可以采取以下措施：
    
    - 减少对象的分配：对象分配会触发 GC，因此减少对象分配可以减少 GC 的次数。
    - 使用结构体代替类：结构体是值类型，它们在栈上分配空间，而不是在堆上。这意味着它们不会触发 GC。
    - 使用对象池：对象池允许您重用对象，而不是每次都创建新对象。这样可以减少对象分配和 GC 的次数。
    - 手动调用 GC.Collect()：如果您确定现在是一个合适的时机来进行垃圾回收，您可以手动调用 GC.Collect() 方法来强制执行垃圾回收。
    
    总之，GC 是 C# 中用于自动管理内存的机制。它产生的原因是为了简化内存管理，并避免内存泄漏和内存碎片。为了避免 GC 对程序性能产生负面影响，可以采取一些措施来减少 GC 的次数。
    

## **16、数列1，1，2，3，5，8，13......第n位数是多少？用c#递归算法实现**

```c#
 public static int Fibonacci(int n)

{

    if (n <= 0)

    {

        throw new ArgumentException("n must be greater than 0");

    }

    if (n == 1 || n == 2)

    {

        return 1;

    }

    return Fibonacci(n - 1) + Fibonacci(n - 2);

}
```

## **17、如何实现一个方法多个返回值**

可以使用out参数。通过在参数列表添加多个out参数，然后在方法内部为这些参数赋值，当方法返回时，这些参数的值会被传递给调用方

例：

```c#
public void GetValues（out int x,out int y)

{

x=1;

y=1;

}

int a,b;

GetValues(out a,out b )
```

## **18、简述二分查找**

二分查找的前提是已经排好顺序的一列元素（这里假设从小到达）；首先记录中间元素、最大元素和最小元素，然后判断查找元素和中间元素的大小关系，如果查找元素大于中间元素，则更新最小元素下标为中间元素下标+1，然后在新的数列中重复此操作，直到找到该元素

## **19、C#的匿名函数出现在哪些场景**

C#中的匿名函数是一种没有函数名的函数，它可以在程序运行时动态地创建和调用。C#中的匿名函数出现在许多场景中，以下是其中几个重要的场景：

1. 事件处理：C#中的事件机制允许在某个事件发生时执行一段代码（委托），通常使用匿名函数来简化代码。例如：

```cs
button1.Click += (sender, e) => MessageBox.Show("Button clicked!");
```

2. LINQ查询：C#中的LINQ查询可以通过Lambda表达式、匿名委托等方式实现，其中匿名函数是一种常见的方式。例如：

```cs
var result = list.Where(n => n % 2 == 0);
```

3. 异步编程：C#中的异步编程通常使用Async/Await语法糖实现，其中可以使用匿名函数来定义异步方法。例如：

```cs
async Task<int> GetDataAsync()
{
    return await Task.Run(() => DataService.GetData());
}
```

4. 委托：匿名函数可以被用作参数传递给委托，进而被用于回调函数。例如：

```cs
public delegate void SimpleDelegate();
public void RunDelegate(SimpleDelegate simpleDelegate)
{
    simpleDelegate();
}
RunDelegate(() => Console.WriteLine("Hello, world!"));
```

总之，匿名函数广泛应用于事件处理、LINQ查询、异步编程、委托等许多场景中，可以大大简化代码编写和提高程序的可读性和易用性。

## **20、介绍一下static关键字**

static关键字含义为静态，可以修饰类、成员变量和成员方法，修饰类的时候一般用于创建工具类，修饰成员变量或者方法时代表该变量/方法可以被这个类的所有对象共享，一处更改，其他对象都可以感知。调用方式是通过类名调用，静态的变量或者方法随着类的加载而生成，并且优先于对象生成（当创建一个类的实例时，会先将这个类的静态成员加载进静态内存区，然后才会在堆中存储实例并将引用赋值到栈中）

## **21、单例模式有什么用？该怎么实现？**

在面向对象编程中，会遇到某一个类只希望实例化一个对象的情况，这时候就可以使用单例类，此时全局只能实例出一个此类的对象，就比如moba类游戏中的地图，在每次的游戏过程中只需要创建一张地图即可，所以可以写成单例类。

单例类的实现方法是：

①私有构造函数，防止外部new对象

②创建一个私有静态变量用来存储唯一的实例

③属性访问器，提供唯一的获取该实例的途径

例：

```
class Map
{
    private Map(){}
    private static Map instance;
    public static Map Instance
    {
       get
        {
           if(instance==null)
              {
                 instance=new Map();
              }
           return instance;
        }
    }
}
```
# 二、引擎基础
## **简述游戏动画有几种以及其原理**

主要有关节动画、骨骼动画、单一网格模型动画(关键帧动画)。 单一网格模型动画：由一个完整的网格模型构成，在动画序列的关键帧里记录各个顶点 的 原位置及其改变量，然后插值运算实现动画效果，角色动画较真实。 关节动画：把角色分成若干独立部分，一个部分对应一个网格模型，部分动画 连接成 一 个整体的动画，角色比较灵活； 骨骼动画：广泛应用的动画方式，集成了以上两个方式的优点，骨骼按角色特点组成一 定的层次结构，有关节相连，皮肤作为单一网格蒙在骨骼之外，决定角色的外观。

## **值类型和引用类型的区别？**

值类型：struct 占用内存较小，一般存储在栈中，值类型数据由编译器自主释放，效率 高、速度快； 引用类型：class 占用内存较大，存储在堆中，引用类型由GC调用释放，效率低、速度 慢； 一般来说开发者把一些频繁释放的较小的数据定义为struct，那些生命周期较长数据量较 大 的定义为class。

## **3、NGUI与UGUI的区别？**

UGUI 的Canvas 有世界坐标 和屏幕坐标；NGUI 只有世界坐标； UGUI 通过Mask进行裁剪；但是NGUI 通过Panel 的Clip； NGUI 的渲染顺序 是通过Widget中的深度决定，而UGUI是通过在层级面板的渲染顺序 决定，越靠下越先被渲染； UGUI 不需要绑定碰撞器，可以自动拦截事件，NGUI 需要 自行绑定 碰撞器； UGUI的锚点是相对于 父物体的，没有提供其他选项，NGUI 的锚点 相对的目标是可以 自行设置的。 NGUI 有比较强大的动画系统等。

## **4、Image和RawImage的区别？**

Imgae比RawImage更消耗性能； Image只能使用Sprite属性的图片，但是RawImage什么样的都可以使用； Image适合放一些有操作的图片，平铺、九宫格、裁剪等（Image Type）； RawImage放单独展示的图片即可，性能会比Image好很多 。

## **5、简述你对协同程序的理解，什么情况下时候协同程序？**

协同程序其本质是迭代器，核心语法是用yiled return 关键字，在特定时间返回 IEnumerator的接口对象； 在unity里主要用来做延迟，延迟帧数，延迟时间，延迟到某个方法执行之后，延迟到某 个行为结束等； 它运行与主线程，在一帧update之后进行判断，当yield return语法会挂起，当条件满 足时会继续往下执行，是对多线程支持不足的一种替代方案。 
a、用来延时； 
b、用来异步加载等待； 
c、加载WWW； 
d、控制代码在特定的时机执行。

## **6、如何实现UI界面的多屏幕适配?**

在界面实际运行与不同的屏幕中时，基于设计分辨率的高度进行等比缩放，这样可以保 证UI各个控件的比例不变。 如果拉伸后出现UI显示不完整的情况可以通过调整相机的正交大小来改变。 多出的黑边 一般采用挡板的形式来进行控，当然，也可以直接使用UGUI中的锚点对各个 控件进行父子节点的绑定来控制显示位置。

## **7、为什么 Unity3D 中会发生在组件上出现数据丢失的情况？**

有可能是组件所挂载的游戏物体被销毁掉了。

## **8、如何安全的在不同工程间安全地迁移 Assets 数据？三种方法；**

a、将Assets目录和Library目录一起迁移； 
b、导出包； 
c、用unity自带的assets Server功能

## **9、请简述GC（垃圾回收）产生的原因，并描述如何避免？**

 GC是一种自动的内存管理机制，用于释放程序中不再使用的内存，产生的原因是程序运行时动态分配内存，当不再需要某个对象时，如果程序没有显示的释放该对象所占用的内存，那么这块内存就会被认为是垃圾，当到达阈值时会开启GC的过程。

①可以通过对象池减少对象创建和销毁的过程

②减少对象的分配，对象分配会触发GC

③使用结构体代替类，结构体是值类型，在栈上分配内存而不是在堆上，这样就不会触发GC

④手动调用GC.Collect进行垃圾回收

## **10、当一个细小的高速物体撞向另一个较大的物体时，会出现什么情况？如何避免？**

会发生穿透现象，小物体直接穿过大物体，这是因为在物理模拟中，碰撞检测和相应都是以离散的时间步长进行的，无法准确处理高速撞击的情况

可以通过增加物体的碰撞检测精度来避免或者将物体的碰撞器调整厚一些

## **11、资源动态加载到内存的几种方式？**

a、从Resources文件夹中加载，Resources.Load； 
b、从某个特定地址加载资源；www 一般是异步加载； 
c、File类型加载文件 File.ReadAllBytes File.ReadAllText等。

## **12、u3d 中碰撞器和触发器的区别？**

触发舍去了碰撞的效果，保留了碰撞的数据信息。

## **13、CharacterController 和 Rigidbody 的区别？**

刚体是真实的物理模拟，包含重力、质量、物理材质等等物理相关属性，但是物理计算 消耗比较大； 角色控制器也包含碰撞信息和重力自适应，是一种简化的刚体。 如果项目中只是为了让游戏物体具有一些基本的物理效果，比如人物 推荐使用 CharacterController 。

## **14、什么叫做链条关节？**

Hinge Joint ，他可以模拟两个物体间用一根链条连接在一起的情况，能保持两个物体在 一个固定距离内部相互移动而不产生作用力， 但是达到固定距离后就会产生拉力。 （简单说就是弹簧）

## **15、什么是序列化？**

序列化简单理解成把对象转换为容易传输的格式的过程。 比如，可以序列化一个对象， 然后在客户端和服务器端之间传输该对象 。

## **16、什么是导航网格（ NavMesh）？**

导航网格用于描述游戏中可行走的表面，允许在游戏中寻找从一个可行位置到另一个可行位置的路径，实现游戏角色的自动寻路

## **17、string str=null与string str2="" 有什么区别；**

string str=null 字符串的内容为空值； 
string str=“” 为其赋值。 
string str=null与string str=“” 区别 
1. ""分配了内存；null没有分配内存。 
2. 区别 2. ""是一个字符串(String).它在内存中是存在的.而null它是一个空对象.在内存中是 不存在 的。 
3. 区别3. ""占内存，在内存中会分配一个空间；null不占内存. 为空引用。

## **18、Unity3d脚本从唤醒到销毁有着一套比较完整的生命周期，请列出系统自带的几个 重要的方法。**

Awake——>OnEnable–>Start——>Update——>FixedUpdate——>LateUpdate—— >OnGUI——>OnDisable——>OnDestroy

## **19、面向对象和面向过程的区别以及优缺点？**

面向过程式分析出解决问题的步骤，然后一步一步实现，在使用时分步调用； 
面向对象是把问题分解成各个对象，建立的对象并不是为了完成一个步骤，而是描述一 种行为。 
面向过程： 优点：性能高 ； 
缺点：不易维护 不易复用 不易扩展 。 
面向对象： 
优点：易维护 易复用 以扩展 更加灵活； 
缺点：性能低，类调用是需要实例化，开销比较大，消耗资源 。

## **20、C#遇到泛型底层是如何编译的？**

生成模板。 值类型 每个值类型调用时都为其创建一个模板，以后再次调用直接使用创建好的那个； 引用类型生成的是object类型的模板 为通用模板