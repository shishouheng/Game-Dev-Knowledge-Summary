# 一、C#部分

## **1、struct和class的区别**

在c#中struct和class都可以代表一种数据类型，但是也有很多区别

①类型不同，struct是值类型，创建实例时变量直接存储值，而class是引用类型，创建实例时存储的是对象的引用而不是对象本身

②内存分配不同，struct由于是值类型所以在栈上分配内存，而class由于是引用类型所以在堆上分配内存。由于堆上的内存在过多时会进行GC，所以使用class会产生更多的开销

③默认值不同，class的默认值可以为null，而struct不可以

④继承方式不同，class支持继承和多态，而struct不支持。

综上所述class更为灵活，虽然开销更大但是在内部可以写复杂的逻辑，而且支持继承和多态，所以在数据较大并且复杂的时候，应当使用class，当数据较小并且简单时使用struct

## **2、C#中堆和栈的区别**

堆和栈是两种不同的内存分配方式，栈在编译期间就已经分配好的内存空间，存储着函数的参数、局部变量、值类型和引用类型的引用地址，并且存在着先进后出，后进先出的顺序。
而堆是程序运行期间动态分配的内存空间，其内部是无序的并且空间更大，引用类型被声明时都会存储在堆中，并将其在堆中的引用地址存储在栈上。

## **3、abstract class和interface有什么区别**

- 成员：接口只能包含方法、属性、事件和索引器的签名，不能有具体的实现。抽象类则可以包含非抽象方法，也可以定义非静态的类变量
- 继承：一个类可以实现多个接口，但只能继承一个类，借助接口可以间接实现多继承
- 实例化：都不可以被实例化
- 方法实现：继承接口的类必须实现接口的所有成员；继承抽象类的非抽象类必须实现抽象类中的所有抽象方法
- 修改：接口增加新方法时所有实现该接口的类都必须修改以实现新方法。而抽象类可以添加新的方法并提供默认实现
- 使用场景：如果对象存在多个功能相近且关系紧密的版本，则使用抽象类。如果对象关系不紧密，但是拥有相同的功能则使用接口

## **4、C#中委托是什么？事件是不是一种委托？有什么不同？**

委托是一种类型，可以用于封装一个或者多个方法，并允许将这些方法作为参数传递给其他方法。委托实际上是一种函数指针，可以用于调用方法

事件是一种机制，允许对象在特定条件下触发一个或多个方法。事件通常与委托一起使用，以便事件发生时调用相应的方法

事件对委托进行了封装，只能在其所在的类内部触发，但是可以在类外部增加或删除需要相应的方法，而委托可以在任何地方被调用，降低了安全性

## **5、C#实现多态的过程中overload重载和override重写的区别**

重载和重写具有本质性区别，重载只是说具有相同的方法名，但参数的类型、顺序、数量不同，当调用时会根据传入的参数的类型、顺序和数量来调用相应的方法。参数的重写是指将一个方法在派生类中重新定义其逻辑

## **6、ref和out有什么区别**

在c#中，ref和out都是用来传递方法参数的关键字，可以使我们在方法内部修改参数的值并将修改后的值传回（也就是使值类型具有类似引用类型的效果），但两者之间也存在着区别

使用ref关键字之前必须初始化这个参数，然后在内部对参数进行修改，修改后的值会返回出来。而使用out关键字之前不需要对这个参数进行初始化，但是在方法内部必须对这个参数赋值，修改后的参数同样也会返回出来。

ref和out都可以使值类型变量达到类似引用类型变量的效果，但是ref有进有出，out只出不进

## **7、字符串string str=null和string str=""和string str=string.Empty的区别是什么**

string str=""和string str=string.Empty没有任何区别，都表示在托管堆中开辟一块没有任何内容的区域然后将这块区域的地址赋值给str，都表示一个长度为0的字符串，而string str=null表示没有任何的引用对象

## **8、什么是扩展方法**

在c#中定义扩展方法时，可以为现有类添加新的方法而不需要修改原始类的定义或创建子类，这对于在无法访问原始类的源代码时添加新功能非常有用（但也应尽量避免使用，因为会使代码难以理解和维护）

使用扩展方法时必须满足两个条件
①扩展方法必须定义在静态类中
②扩展方法的第一个参数指定要扩展的类型，并且要用this关键字标识

例：

```c#
public static class MyClassExtensions
{
    public static void MyMethod(this MyClass myClass,int x)
      {
         //这里实现MyMethod的逻辑    
      }
}
MyClass myObject=new MyClass();
myObject.MyMethod(10);
```

## **9、as和is的区别**

is关键字用于类型之间的检查，如果检查的两个类型一致那么返回true否则返回false，as关键字用于类型之间的转换，如果转换成功则返回转换后的对象，否则返回null

## **10、string和stringBuilder的区别，两者性能如何**

string和stringBuilder都表示字符串，但是有显著区别，当一个string类型的变量生成时无法修改除非重新生成一个string类型的字符串，而stringBuilder生成的字符串可以进行插入、删除、修改。对于简单的字符串连接操作，在性能上stringBuilder不一定总是优于string，因为stringBuilder对象的创建也会浪费性能，所以在字符串连接较少的情况下滥用stringBuilder会导致性能的浪费而非节约，只有在大量且无法预知次数的字符串操作才考虑stringBuilder的使用

## **11、面向对象的三大特点，请简要叙述**

 面向对象编程是一种编程规范，其三大特点就是封装、继承和多态
 - 封装：封装是指将数据和对数据的操作封装在类中，通过定义外部可访问的接口来控制对内容的访问。封装可以隐藏内部的实现细节，只暴露必要的方法和属性，提高了代码的可维护性和安全性
 - 继承：继承是一种创建新类的方式，新创建的子类可以继承现有父类的属性和方法，并可以添加新的属性和方法或覆盖父类的方法。这样可以实现代码复用，提高开发效率
 - 多态：多态是指一个对象可以以多种形式存在。多态允许我们使用一个抽象的父类类型来引用具体的子类对象，从而实现同样的操作可以根据对象的实际类型而表现出不同的行为。多态性提高了代码的灵活性和可扩展性

多态可以通过继承、接口、抽象类、虚方法、重载等方式实现

## **12、什么是拆装箱，简述其弊端**

在c#中所有类型都继承于object这个最基类，所以所有类型都可以向上转型为object类，当实现某一功能不确定需要传入什么类型的参数时，可以使用object代替，如果传入的类型是值类型时，会发生装箱操作，然后将转换后的object类型在转换回值类型时，会发生拆箱操作，但是在装箱和拆箱的过程会带来性能的开销，这是拆装箱的弊端之一，第二就是存在类型不安全的问题，因为编译器无法在编译期间判断转换的类型和原有类型是否兼容，所以在运行期间可能会异常报错。

为避免这两种弊端，c#提供了一种更好的解决方式，即泛型，因为在泛型中，类型参数在编译期间就确定了，所以编译器可以在编译期间检查类型的安全性，并且泛型还能够提高代码的重用性和性能，所以在能使用泛型解决问题的情况下应该尽量避免拆装箱。

## **13、拆装箱的内存原理**

```
int i=123;
object o=i;
int j=(int)o;
```

上面的代码是一个简单的拆装箱过程，在这个过程中首先执行int i=123,由于i是值类型，所以会在栈中开辟一块内存存储123，然后执行第二段代码，object o=i；由于i是值类型，object是引用类型，所以会先将i的数据拷贝一份，然后在堆中开辟一块内存将拷贝的数据写入堆中，同时将这块内存区域的引用传递给对象o。接着执行第三段代码，由于j是值类型，o是引用类型，所以需要进行强制性转换，此时会将堆中存储的数据拷贝一份，然后拷贝进栈中。

## **14、常规容器和泛型容器有什么区别**

①类型安全性：泛型容器是类型安全的，它在编译器就能够检测到类型错误，因此可以避免运行时出现类型不匹配的错误。而常规容器由于是以object类型作为存储元素的元素，所以可以存储任意类型的数据，这就无法避免的存在数据类型不安全的问题

②性能：泛型容器的性能更好，因为泛型容器可以直接存储值类型数据，而常规容器则需要将值类型装箱未引用类型，导致额外的性能开销

③使用方式：泛型容器需要在创建对象时指定要存储的数据类型，这样能够在编译期检查类型错误，而常规容器不需要。

常规容器：

- ArrayList：动态数组，可以存储任何类型的对象。
- Hashtable：基于哈希表的字典，可以存储键值对。
- Queue：先进先出的队列，可以存储任何类型的对象。
- Stack：后进先出的栈，可以存储任何类型的对象。

泛型容器：

- List：动态数组，可以存储特定类型的对象。
    
- Dictionary<TKey, TValue>：基于哈希表的字典，可以存储键值对。
    
- Queue：先进先出的队列，可以存储特定类型的对象。
    
- Stack：后进先出的栈，可以存储特定类型的对象
## **15、请简述GC产生的原因，并描述如何避免**
   
GC是.Net平台的内存管理机制，作用就是管理内存，避免内存泄漏和溢出。当一个对象不再被使用时就会被标记为是垃圾，当对象的数量到达阈值时，就会触发GC，对这些垃圾进行清理

避免GC频繁触发的方式有以下：
- 显示释放资源：使用完对象后，及时调用释放资源的方法，比如关闭文件、释放连接等。
- 避免创建过多的临时对象：可以通过对象池对对象进行回收利用，避免频繁的创建和销毁
- 事件订阅和取消订阅：如果没有取消订阅，事件的发布者会持有订阅者的引用，导致订阅者无法被垃圾回收
- 尽量使用值类型：值类型在栈上分配内存，而引用类型在堆上分配内存。能用值类型替代的尽可能使用值类型

## **16、数列1，1，2，3，5，8，13......第n位数是多少？用c#递归算法实现**

```c#
 public static int Fibonacci(int n)

{

    if (n <= 0)

    {

        throw new ArgumentException("n must be greater than 0");

    }

    if (n == 1 || n == 2)

    {

        return 1;

    }

    return Fibonacci(n - 1) + Fibonacci(n - 2);

}
```

## **17、如何实现一个方法多个返回值**

可以使用out参数。通过在参数列表添加多个out参数，然后在方法内部为这些参数赋值，当方法返回时，这些参数的值会被传递给调用方

例：

```c#
public void GetValues（out int x,out int y)

{

x=1;

y=1;

}

int a,b;

GetValues(out a,out b )
```

## **18、简述二分查找**

二分查找的前提是已经排好顺序的一列元素（这里假设从小到达）；首先记录中间元素、最大元素和最小元素，然后判断查找元素和中间元素的大小关系，如果查找元素大于中间元素，则更新最小元素下标为中间元素下标+1，然后在新的数列中重复此操作，直到找到该元素

## **19、C#的匿名函数出现在哪些场景**

C#中的匿名函数是一种没有函数名的函数，它可以在程序运行时动态地创建和调用。C#中的匿名函数出现在许多场景中，以下是其中几个重要的场景：

1. 事件处理：C#中的事件机制允许在某个事件发生时执行一段代码（委托），通常使用匿名函数来简化代码。例如：

```cs
button1.Click += (sender, e) => MessageBox.Show("Button clicked!");
```

2. LINQ查询：C#中的LINQ查询可以通过Lambda表达式、匿名委托等方式实现，其中匿名函数是一种常见的方式。例如：

```cs
var result = list.Where(n => n % 2 == 0);
```

3. 异步编程：C#中的异步编程通常使用Async/Await语法糖实现，其中可以使用匿名函数来定义异步方法。例如：

```cs
async Task<int> GetDataAsync()
{
    return await Task.Run(() => DataService.GetData());
}
```

4. 委托：匿名函数可以被用作参数传递给委托，进而被用于回调函数。例如：

```cs
public delegate void SimpleDelegate();
public void RunDelegate(SimpleDelegate simpleDelegate)
{
    simpleDelegate();
}
RunDelegate(() => Console.WriteLine("Hello, world!"));
```

总之，匿名函数广泛应用于事件处理、LINQ查询、异步编程、委托等许多场景中，可以大大简化代码编写和提高程序的可读性和易用性。

## **20、介绍一下static关键字**

static关键字含义为静态，可以修饰类、成员变量和成员方法，修饰类的时候一般用于创建工具类，修饰成员变量或者方法时代表该变量/方法可以被这个类的所有对象共享，一处更改，其他对象都可以感知。调用方式是通过类名调用，静态的变量或者方法随着类的加载而生成，并且优先于对象生成（当创建一个类的实例时，会先将这个类的静态成员加载进静态内存区，然后才会在堆中存储实例并将引用赋值到栈中）

## **21、单例模式有什么用？该怎么实现？**

在面向对象编程中，会遇到某一个类只希望实例化一个对象的情况，这时候就可以使用单例类，此时全局只能实例出一个此类的对象，就比如moba类游戏中的地图，在每次的游戏过程中只需要创建一张地图即可，所以可以写成单例类。

单例类的实现方法是：

①私有构造函数，防止外部new对象

②创建一个私有静态变量用来存储唯一的实例

③属性访问器，提供唯一的获取该实例的途径

例：

```
class Map
{
    private Map(){}
    private static Map instance;
    public static Map Instance
    {
       get
        {
           if(instance==null)
              {
                 instance=new Map();
              }
           return instance;
        }
    }
}
```

## 22、排序算法和二分查找

**冒泡：两两对比，顺序错误就调换**

**选择：从未排序序列中选择最小或者最大的，然后放到已排序序列末尾或者开头，然后从剩余未排序选择最小或最大，放到已排序序列末尾或开头**

**插入：将第一个元素堪为已排序的，从第二个元素开始与已排序元素比较，找到位置插入，如果当前元素小于已排序的某个元素，就后移然后为当前元素腾出插入位置，重复上面步骤，直到排序完成**

**希尔：插入的一种优化版本，原理类似，区别就是将整个序列分为多个子序列，然后对每个子序列进行插入，每个子序列排序完后再进行一次插入就完成所有排序**

**快速：要用到递归思想，思路就是选择一个基准元素，然后将排序序列分为两个子序列，其中一个子序列的元素都小于基准元素，另一个序列都大于基准元素，然后对再对每个子序列重复上述排序，直到完成**

**二分查找：是在已排序序列中查找某个元素，先找出中间位置元素，然后比较中间元素与查找元素，等于说明找到了，查找元素小于中间元素，则以开头为起始，中间元素-1为结尾继续执行，以此类推**

[代码](https://github.com/shishouheng/Unity-learning/blob/main/note/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95.md)

# 二、引擎基础
## **1、简述游戏动画有几种以及其原理**

主要有关节动画、骨骼动画、单一网格模型动画(关键帧动画)。 单一网格模型动画：由一个完整的网格模型构成，在动画序列的关键帧里记录各个顶点 的 原位置及其改变量，然后插值运算实现动画效果，角色动画较真实。 关节动画：把角色分成若干独立部分，一个部分对应一个网格模型，部分动画 连接成 一 个整体的动画，角色比较灵活； 骨骼动画：广泛应用的动画方式，集成了以上两个方式的优点，骨骼按角色特点组成一 定的层次结构，有关节相连，皮肤作为单一网格蒙在骨骼之外，决定角色的外观。

## **2、值类型和引用类型的区别？**

值类型：struct 占用内存较小，一般存储在栈中，值类型数据由编译器自主释放，效率 高、速度快； 引用类型：class 占用内存较大，存储在堆中，引用类型由GC调用释放，效率低、速度 慢； 一般来说开发者把一些频繁释放的较小的数据定义为struct，那些生命周期较长数据量较 大 的定义为class。

## **3、NGUI与UGUI的区别？**

UGUI 的Canvas 有世界坐标 和屏幕坐标；NGUI 只有世界坐标； UGUI 通过Mask进行裁剪；但是NGUI 通过Panel 的Clip； NGUI 的渲染顺序 是通过Widget中的深度决定，而UGUI是通过在层级面板的渲染顺序 决定，越靠下越先被渲染； UGUI 不需要绑定碰撞器，可以自动拦截事件，NGUI 需要 自行绑定 碰撞器； UGUI的锚点是相对于 父物体的，没有提供其他选项，NGUI 的锚点 相对的目标是可以 自行设置的。 NGUI 有比较强大的动画系统等。

## **4、Image和RawImage的区别？**

Imgae比RawImage更消耗性能； Image只能使用Sprite属性的图片，但是RawImage什么样的都可以使用； Image适合放一些有操作的图片，平铺、九宫格、裁剪等（Image Type）； RawImage放单独展示的图片即可，性能会比Image好很多 。

## **5、简述你对协同程序的理解，什么情况下时候协同程序？**

协同程序其本质是迭代器，核心语法是用yiled return 关键字，在特定时间返回 IEnumerator的接口对象； 在unity里主要用来做延迟，延迟帧数，延迟时间，延迟到某个方法执行之后，延迟到某 个行为结束等； 它运行与主线程，在一帧update之后进行判断，当yield return语法会挂起，当条件满 足时会继续往下执行，是对多线程支持不足的一种替代方案。 
a、用来延时； 
b、用来异步加载等待； 
c、加载WWW； 
d、控制代码在特定的时机执行。

## **6、如何实现UI界面的多屏幕适配?**

在界面实际运行与不同的屏幕中时，基于设计分辨率的高度进行等比缩放，这样可以保 证UI各个控件的比例不变。 如果拉伸后出现UI显示不完整的情况可以通过调整相机的正交大小来改变。 多出的黑边 一般采用挡板的形式来进行控，当然，也可以直接使用UGUI中的锚点对各个 控件进行父子节点的绑定来控制显示位置。

## **7、为什么 Unity3D 中会发生在组件上出现数据丢失的情况？**

有可能是组件所挂载的游戏物体被销毁掉了。

## **8、如何安全的在不同工程间安全地迁移 Assets 数据？三种方法；**

a、将Assets目录和Library目录一起迁移； 
b、导出包； 
c、用unity自带的assets Server功能

## **9、请简述GC（垃圾回收）产生的原因，并描述如何避免？**

 GC是一种自动的内存管理机制，用于释放程序中不再使用的内存，产生的原因是程序运行时动态分配内存，当不再需要某个对象时，如果程序没有显示的释放该对象所占用的内存，那么这块内存就会被认为是垃圾，当到达阈值时会开启GC的过程。

①可以通过对象池减少对象创建和销毁的过程

②减少对象的分配，对象分配会触发GC

③使用结构体代替类，结构体是值类型，在栈上分配内存而不是在堆上，这样就不会触发GC

④手动调用GC.Collect进行垃圾回收

## **10、当一个细小的高速物体撞向另一个较大的物体时，会出现什么情况？如何避免？**

会发生穿透现象，小物体直接穿过大物体，这是因为在物理模拟中，碰撞检测和相应都是以离散的时间步长进行的，无法准确处理高速撞击的情况

可以通过增加物体的碰撞检测精度来避免或者将物体的碰撞器调整厚一些

## **11、资源动态加载到内存的几种方式？**

a、从Resources文件夹中加载，Resources.Load； 
b、从某个特定地址加载资源；www 一般是异步加载； 
c、File类型加载文件 File.ReadAllBytes File.ReadAllText等。

## **12、u3d 中碰撞器和触发器的区别？**

触发舍去了碰撞的效果，保留了碰撞的数据信息。

## **13、CharacterController 和 Rigidbody 的区别？**

刚体是真实的物理模拟，包含重力、质量、物理材质等等物理相关属性，但是物理计算 消耗比较大； 角色控制器也包含碰撞信息和重力自适应，是一种简化的刚体。 如果项目中只是为了让游戏物体具有一些基本的物理效果，比如人物 推荐使用 CharacterController 。

## **14、什么叫做链条关节？**

Hinge Joint ，他可以模拟两个物体间用一根链条连接在一起的情况，能保持两个物体在 一个固定距离内部相互移动而不产生作用力， 但是达到固定距离后就会产生拉力。 （简单说就是弹簧）

## **15、什么是序列化？**

序列化简单理解成把对象转换为容易传输的格式的过程。 比如，可以序列化一个对象， 然后在客户端和服务器端之间传输该对象 。

## **16、什么是导航网格（ NavMesh）？**

导航网格用于描述游戏中可行走的表面，允许在游戏中寻找从一个可行位置到另一个可行位置的路径，实现游戏角色的自动寻路

## **17、string str=null与string str2="" 有什么区别；**

string str=null 字符串的内容为空值； 
string str=“” 为其赋值。 
string str=null与string str=“” 区别 
1. ""分配了内存；null没有分配内存。 
2. 区别 2. ""是一个字符串(String).它在内存中是存在的.而null它是一个空对象.在内存中是 不存在 的。 
3. 区别3. ""占内存，在内存中会分配一个空间；null不占内存. 为空引用。

## **18、Unity3d脚本从唤醒到销毁有着一套比较完整的生命周期，请列出系统自带的几个 重要的方法。**

Awake——>OnEnable–>Start——>Update——>FixedUpdate——>LateUpdate—— >OnGUI——>OnDisable——>OnDestroy

## **19、面向对象和面向过程的区别以及优缺点？**

面向过程式分析出解决问题的步骤，然后一步一步实现，在使用时分步调用； 
面向对象是把问题分解成各个对象，建立的对象并不是为了完成一个步骤，而是描述一 种行为。 
面向过程： 优点：性能高 ； 
缺点：不易维护 不易复用 不易扩展 。 
面向对象： 
优点：易维护 易复用 以扩展 更加灵活； 
缺点：性能低，类调用是需要实例化，开销比较大，消耗资源 。

## **20、C#遇到泛型底层是如何编译的？**

生成模板。 值类型 每个值类型调用时都为其创建一个模板，以后再次调用直接使用创建好的那个； 引用类型生成的是object类型的模板 为通用模板


# 三、 引擎中级

## **1、简述unity中实现延迟操作的几种方式**

- 使用协程配合yield return可以实现延迟一帧，延迟一定时间和延迟到一个固定的节点。
- Invoke和InvokeRepeating实现方法延迟调用
- 使用Time.DeltaTime在Update中累加实现自定义延迟

## **2、Unity的新版动画比老版动画增加了哪些功能**

- 增加了人形骨骼humanoid实现动画重定向
- 增加了Animator动画控制器，可以在编辑界面上实现对动画的切换和混合

## **3、如何实现动画的倒播**

把动画播放的起始位置放在最后一帧，然后将动画的播放速度设置为负数

## **4、实现人物向前跳跃有哪些方式**

- 使用跟运动模式（Root Motion）动画实现人物位置的变更
- 使用插值搭配三角函数来实现角色从起始位置以抛物线形式跳跃到目标位置
- 使用Unity的物理系统，通过向前方施加力的方式进行控制


## **5、用Switch实现状态机有什么问题？简述FSM状态机的实现流程**

用switch实现的状态机存在代码臃肿、逻辑混乱、耦合性强、不易维护的缺点

FSM状态机的实现流程是首先实现基础的状态父类，封装状态的一些虚函数（如进入状态、状态初始化、状态更新、状态退出等）

然后让每一个状态的脚本都继承并实现该父类

最后配合管理者模式实现状态机的管理类，负责对各个状态进行存储、切换、移除、获取等，并在系统中缓存一个当前的状态对象，切换状态时直接修改状态对象的指向即可

## **6、简述AStar寻路算法的实现原理**

Astar算法是一种在图形和网格中寻找最短路径的算法。实现原理是：

- 将所有的位置信息通过一个一个的网格表示
- 创建一个开启列表和一个关闭列表，分别存储等待检查的方格和不需要检查的方格
- 将起点放入开启列表，遍历其周围所有方格并放入开启列表中同时将起点作为它们的父方格，计算每个方格的靠谱度（估价函数）:F=G+H（G表示从起点移动到当前方格的距离，H表示从当前方格移动到终点的距离，移动方式可以根据需求自行设置）
- 将开启列表中F值最低的方格从开启列表删除并放入关闭列表中，接着重复上面的步骤遍历该方格周围的所有方格并计算它们的F值（障碍物和已经在关闭列表中的不需要考虑），如果未在开启列表中则放入开启列表。（如果某个相邻方格已经在开启列表中，则计算通过新的路径到达它所得到的G值是否会更低，如果更低则设置其父方格为当前方格）
- 重复上面的步骤直到终点出现在开启列表中
- 找回路径，所有的父方格就是路径

## **7、使用Navigation系统进行场景烘焙前需要做好哪些准备工作**

将需要烘焙的物体设置为导航静态，并设置好导航代理的参数

## **8、Unity中使用多线程开发需要注意什么？如何解决**

Unity不能在分线程调用unity的API，解决方案是使用时间分割策略，如协程

## **9、写出AssetBundle的函数和参数列表**

1.BuildPipeline.BuildAssetBundles(string outputPath,BuildAssetBundleOptions options,BuildTarget targetPlatform)
- outputPath:AssetBundle的输出路径
- options:AssetBundle的构建选项，可以指定是否压缩、是否包含依赖项等
- targetPlatform：AssetBundle的目标平台，可以是Android、IOS、Windows等

2.AssetBundle.LoadFromFile(string path)
- path:AssetBundle的文件路径，可以是相对路径或绝对路径

3.AssetBundle.LoadFromMemory(byte[]binary)
- binary:AssetBundle的二进制数据
## **10、使用WWW加载StreamingAssets文件夹的资源时需要注意什么？**

- 在不同平台下StreamingAssets的路径是不同的
- www类加载数据时不会立即返回结果，而是在数据加载完成后返回结果，而资源加载又需要时间，因此需要搭配协程使用，避免阻塞主线程

## **11、为什么要使用Assetbundle.UnLoad(bool)进行卸载？如何理解参数中bool的作用**

AssetBundle下载完成后 本地会生成一个内存镜像文件 在资源加载完成后会把资源加入到缓存中 Unload是卸载函数 可以用来协程镜像文件或者是通过load所加载的缓存资源 bool为false 仅卸载镜像文件 bool为true 则卸载镜像文件和load加载的资源 如果资源一直加载但是不卸载 会导致内存中涵盖大量的垃圾 如果内存不足 则导致效率下降 出现运行缓慢的问题

## **12、代码实现C#单例抽象父类模板**
```c#
public abstract class Singleton<T> where T : new()
{
    private static T ms_instance;

    protected Singleton() { }

    public static T Instance
    {
        get
        {
            if (ms_instance == null)
            {
                ms_instance = new T();
            }

            return ms_instance;
        }
    }
}

```


## **13、详细描述 Unity为什么要选择C#进行跨平台游戏开发?**

1. 跨平台性：C#是一种面向对象的编程语言，它的跨平台性非常好。Unity引擎本身是跨平台的，可以在多个操作系统上运行，包括Windows、Mac、Linux、iOS、Android等。通过使用C#作为脚本语言，可以在不同平台上共享和重用代码，减少开发人员在不同平台上的工作量。
    
2. 强大的生态系统：C#是一种非常流行的编程语言，在开发社区中有大量的资源和工具可用。Unity作为一个广泛使用的游戏引擎，有庞大的开发者社区和丰富的插件生态系统。使用C#可以更方便地与这些资源和工具进行集成和交互，加速游戏开发的进程。
    
3. 性能和可扩展性：C#是一种高性能的编程语言，具有良好的执行效率和内存管理机制。Unity引擎使用了Mono运行时环境来解释和执行C#脚本，它的性能表现非常出色。另外，C#还提供了很多高级特性和库，可以方便地实现游戏中的各种功能和效果，提高开发效率和游戏性能。
    
4. 开发效率：C#是一种简洁、易读、易学的编程语言，具有很强的可读性和可维护性。它支持面向对象的编程范式，并提供了很多高级特性，如委托、事件、LINQ等，能够简化开发过程，提高代码的可重用性和可扩展性。同时，Unity提供了丰富的API和工具，可以快速开发各种游戏功能，加速开发进程。


## 14、unity中协程与线程的区别

在unity中，协程与线程是两种不同的并发执行方式（即在同一时间执行多个指令序列）

线程是操作系统提供的基本执行单元，可以独立运行在不同的处理器核心上，并且不会阻塞主线程，可以用于执行耗时操作，在unity中可以使用system.Threading命名空间的Thread类来创建和管理线程，但是Unity中的大部分API只能在主线程调用，

而协程是基于时间分割策略实现的一种轻量级的线程，本质上还是在主线程执行。
协程是通过迭代器+yield return关键字实现的，将需要在一帧内完成的任务分布到多个帧内完成，有效避免了同一帧执行任务过多而可能导致的卡顿现象

迭代器的作用是返回容器中的数据，那unity中的协程为什么可以实现暂停执行和继续执行呢？

unity为我们提供了一些封装好的迭代器对象，如WaitForSeconds、WaitForEndOfFrame等等，这些类都实现了IEnumerator接口，并且在内部会记录当前时间与等待时间，同时会在每一帧更新时间，

当我们通过StartCoroutine开启一个协程后，这个协程会挂在Monobehaviour下，并在Update和LateUpdate之间检查这个Monobehaviour下面的所有协程，并唤醒满足条件的协程

当协程开启执行到yield return xxx时，会将一个迭代器返回出去，然后在每一帧判断是否到达设定的时间，如果到达就执行下一步操作，没到达就继续在下一帧进行检查，以此实现协程的暂停与开启



## 15.什么是三次握手

三次握手是建立TCP连接的过程，它需要客户端和服务器总共发送3个包以确认连接的建立

- 第一次握手：客户端向服务器发送一个SYN包，并等待服务器确认。发送完毕后，客户端进入SYN_SENT状态，等待服务器确认
- 第二次握手：服务器收到SYN包后，会向客户端发送一个SYN+ACK包确认连接请求。此时服务器进入SYN_RCVD状态
- 第三次握手：客户端收到SYN+ACK包后，会向服务器发送一个ACK包。发送完毕后客户端进入ESTABLISHED状态。服务器收到ACK包后也进入这个状态

完成以上三次握手后，TCP连接就建立成功了，客户端和服务器就可以开始数据传输


## 16、TCP和UDP在游戏开发中的使用方式和需要注意的地方

TCP和UDP都是网络传输协议，但它们之间也有一些显著的区别：
- TCP是一种面向连接的协议，它需要在发送数据之前先建立连接，并保证数据的可靠性和完整性，而UDP是一种无连接的协议，不需要建立连接，也不保证数据的可靠性和完整性
- 在unity开发中TCP通常用于实现游戏中的聊天系统、排行榜、用户登录等功能。而UDP通常用于实现游戏中的语音连麦、位置同步、视频流传输等功能（这是因为这类功能对实时性要求较高，使用UDP可以减少延迟，即使有数据丢失，丢失的数据包也可以被后续的数据包所替代）
- TCP的连接建立需要时间，会增加网络延迟，因此不适用于需要快速响应的场景，而且TCP协议对于网络质量要求较高，网络不稳定时可能会导致连接断开或数据丢失。而UDP协议不保证数据的可靠性和完整性，因此需要在应用层进行数据校验和重传等处理

## 17、帧同步和状态同步原理

帧同步是指客户端把操作上传服务端，服务端不模拟操作，把操作转发给所有客户端，这意味着所有的游戏逻辑都在客户端执行，服务端只负责转发客户端的操作。例如，玩家执行一个攻击操作，对受击者造成了一定的伤害，然后客户端会将一系列的操作上传到服务端并分发给所有的客户端，让所有玩家接收到这个操作的发生

优点：
- 开发效率高，因为战斗逻辑都写在客户端，服务端只负责转发操作消息，双端开发时不需要做额外的对接工作
- 客户端之间的同步相对较快，由于不需要服务端进行模拟计算，客户端之间的同步速度较快，可以减少延迟

缺点：
- 安全性低，所有数据都在客户端，所以解析客户端数据之后，很容易出现作弊
- 对网络延迟的适应性差，如果一个玩家的延迟较高，可能导致所有玩家的体验都不好

状态同步是指客户端把操作上传服务端，服务端根据客户端上传的操作来计算游戏状态的变换，然后把模拟的结果转发给所有客户端。这意味着在状态同步中，游戏逻辑主要在服务端执行，客户端负责显示游戏状态和接收用户输入。例如，玩家执行一个攻击动作，服务端会根据这个攻击操作来计算被攻击者的血量减少多少，然后将这个结果发送给所有客户端

优点：
- 安全性高，因为状态同步的所有逻辑都是在服务端计算的，数据就难以被获取，作弊成本的增加
- 服务端进行模拟操作可以保证所有客户端的游戏状态保持一致

缺点：
- 开发效率较低，服务端负担较大
- 由于服务端需要进行模拟计算并发送结果，可能会导致网络延迟


综上所述，对于实时性很强同时需要较高的安全性，那可以使用状态同步，否则使用帧同步

## 18、CGPROGRAM是什么

CGPROGRAM是unity中编写shader的语法结构，用于定义一段shader程序，其中可以包含顶点着色器和片元着色器的代码，在一段CGPROGRAM块中通常包含以下几个部分：properties属性、subshader渲染通道和pass渲染过程

## 19、Shader分类和功能

Shader是用于在图形渲染管线中控制光照、颜色、纹理等图像处理的程序。根据功能可以分为以下两类：

- **Vertex Shader（顶点着色器）：** 主要负责处理3D模型的顶点数据。例如，它可以改变顶点的位置、颜色和纹理坐标等属性。在unity中可以使用Vertex Shader来实现各种自定义的顶点操作，例如顶点动画、顶点光照等
- **Pixel Shader（也叫Fragment Shader，片元着色器）：** 主要负责处理像素数据。它接收经过Vertex Shader处理后的顶点数据，然后对每个像素进行颜色计算。在unity中，可以通过片元着色器来实现各种自定义的像素操作，如纹理采样、光照计算、颜色混合等
## 20、数据结构及原理

### 1.线性结构：
所有线性结构的元素都存在着一对一的关系，即除了第一个元素外所有元素都有一个前驱元素，以及除了最后一个元素外所有元素都有一个后继元素
- 数组：最简单的一种线性结构，使用连续的内存空间来存储元素，逻辑意义上相邻的元素在物理空间上也是相邻的，数组分为普通数组、动态数组和泛型动态数组
- 栈：一种先进后出的数据结构，只允许在栈顶进行插入和删除的操作
- 队列：一种先进先出的数据结构，允许在队尾插入元素在队首删除元素
- 链表：由节点组成的数据结构，每个节点除了存储数据元素的信息外，还要存储指向下一个节点的指针，逻辑上相邻的元素在物理空间上不一定相邻

### 2.树形结构：
树形结构是一种非线性的数据结构，其中的元素之间存在一对多的关系，常用的树形结构包括二叉树、AVL数等

二叉树是一种每个节点最多有两个子树的树形结构，并且子树有左右之分，不能任意颠倒顺序

- 满二叉树：即除了叶子节点以外的所有节点都有两个子树
- 完全二叉树：除了叶子节点以外的所有节点都有两颗子树，并且叶子节点的子树都连续集中在左边

二叉树的遍历方式
- 先序遍历：即先遍历根节点，然后左子树，最后右子树
- 中序遍历：即先遍历左子树，然后根节点，最后右子树
- 后序遍历：即先遍历左子树，然后右子树，最后根节点
- 层次遍历：从上往下，从左往右依次遍历


AVL平衡二叉树：
二叉排序树一定程度上可以提高搜索效率，但是如果二叉排序树本身有序时，此时二叉排序树就会变成一个链表，搜索效率下降。而AVL平衡二叉树由于保持了左右子树的高度差不超过1，可以保证二分查找的搜索效率，因此较为常用

平衡二叉树的调整：
一颗平衡二叉树插入新元素时会出现两种情况，一是未打破平衡，二是打破平衡。
当平衡二叉树的平衡被打破时，需要对树进行调整以保持再度的平衡
- LL左旋：插入节点在失衡节点右子树的右边，进行左旋，左旋后多出来的节点变为左子树的右子树
- RR右旋：插入节点在失衡节点左子树的左边，进行右旋，右旋后多出来的节点变为右子树的左子树
- LR左右旋：插入节点在失衡节点左子树的右边，需要先以左子树为根节点进行一次左旋，然后将根节点进行一次右旋，多出来的节点变为右子树的左子树
- RL右左旋：插入节点在失衡节点右子树的左边，需要先以右子树为根节点进行一次右旋，然后将根节点进行一次左旋，多出来的节点变为左子树的右子树

### 3.散列结构

散列结构是一种根据关键字直接访问数据的数据结构，也称为哈希表，常见的散列结构包括哈希表和字典

- Hashtable：存储的是object类型的数据，存在类型不安全和拆装箱的问题，内部无序且长度不定，数据多时效率下降，基于数组实现，增删改查数据块
- Dictionary：泛型版本的Hashtable，内部无序，数据量大时效率低下
- SortDictionary：泛型排序字典，基于二叉查找树实现，使用二分查找检索key，插入效率低下


## 21、UGUI中outline组件的原理

**Outline原理：**
- 在顶点着色器中，根据UI元素顶点的位置，为每个顶点生成一个偏移后的顶点位置。这些偏移后的顶点位置就是描边的轮廓线
- 在片元着色器中，根据轮廓线的位置，将轮廓线的颜色与UI元素的颜色进行混合，生成最终的颜色输出

## 22、yield关键字原理

yield关键字是一个语法糖，可以帮助我们快速的创建迭代器。yield return可以根据返回值类型是IEnumerable还是IEnumerator来告诉编译器创建的是可枚举类型还是枚举器，并且指定了枚举器的下一个可枚举选项。它的原理是通过编译器生成一个状态机来实现的，这个状态机具有四个状态：
- Before：首次调用MoveNext方法前的位置，在第一个可枚举项之前
- Running：调用MoveNext后进入该状态，在该状态使迭代器会检测下一项的位置是否有效，当遇到yield return时会进入到挂起状态并返回yield return 后面的值作为当前枚举型
- Suspend：挂起状态，等待下一次MoveNext调用时唤醒
- End：结束位置，没有可枚举项了



## 23、同步方法和异步方法的区别

同步方法和异步方法的区别在于它们的执行方式和对线程的使用

同步方法：
- 同步方法是按顺序依次执行的，每个方法执行完成后才会执行下一个方法
- 同步方法会阻塞当前线程，直到方法执行完成后才会继续执行下一个操作
- 同步方法适用于需要按照顺序执行的操作，或者不需要额外的线程来执行任务的情况

异步方法：
- 异步方法是可以同时执行的，不需要等待上一个方法执行完成
- 异步方法可以可以在后台线程中继续执行，不会阻塞主线程
- 异步方法适用于需要同时执行多个任务或者执行耗时操作的情况

使用场景：
- 同步方法适用于简单的操作，不涉及到耗时任务并需要按照特定顺序执行。
- 异步方法适用于需要执行耗时操作的情况，如加载大量资源、网络请求、复杂计算等。

在unity中可以使用协程实现异步操作，也可以使用async/await语法来实现异步操作

## 24、网络传输中的同步阻塞和异步非阻塞的区别

同步异步是针对调用者来说的，当调用者发起一个请求后，是否需要等待被调用者的反馈，如果需要等待就是同步，否则就是异步。
阻塞非阻塞是针对被调用者来说的，当被调用者收到一个请求后，做完请求任务才给处发聩就是阻塞，如果收到请求直接给出反馈再去做任务就是非阻塞

因此
- 同步阻塞就是指再需要某些资源时马上发起请求，并暂停本线程之后的程序，直至获得所需的资源
- 异步非阻塞就是指需要某资源时不马上发起请求，而是安排一个以后的时间再发起请求。当到了那时拿出请求时，马上可以得到答复，然后继续执行之后的程序。但如果得到的不是完整的资源，之后周期性的发起请求。再最终获得资源之后，通过回调的方式将结果异步反馈
## 25、Unity中的线程有什么用

线程是操作系统中的一个概念，是进程中的实际运作单位，一个进程可以包含若干个线程。

在unity中子线程是指运行于主线程之外的线程。Unity的主线程主要复杂处理游戏的渲染和更新逻辑。子线程则可以用于处理一些耗时的计算、加载资源、网络请求等操作，避免阻塞主线程。

需要注意的是在Unity中子线程不能执行Unity提供的API，但是可以考虑通过在子线程将任务添加到一个执行队列中，然后在主线程执行这个队列来间接实现调用Unity的API

总之，在unity开发中，使用子线程可以处理耗时的操作，避免阻塞主线程，提高游戏的性能和响应性


## 26、热更新流程

热更新的话分为资源热更和代码热更。在游戏打开的时候会进行一次版本检测，如果发现游戏版本有更新，会自动从服务端请求下载更新的文件。不管是资源还是代码更新都是通过assetbundle打包放到服务端实现的。

对于资源热更，可以直接将需要更新的资源进行标记AssetBundle，然后通过一个BuildAssetbundle脚本对所有的资源进行一个打包，然后上传到服务端即可。并通过资源管理系统中每个资源的标识符来对旧的资源进行替代

对于代码热更，要先对可能会热更的代码添加xlua中的hotfix特性，表面该段代码可能在未来会被热更，然后在lua脚本中确定需要替换的是哪一个被标记了hotfix的代码，然后将该lua脚本打包为assetbundle并上传到服务端，客户端请求下载后就完成了代码的热更新

## 27、lua实现面向对象的原理

lua本身没有面向对象的概念，但是可以通过元表和元方法来模拟出类似面向对象的特性。

- 封装：在Lua中封装可以直接用表来实现，用一个表代表一个对象，表中的字段来表示对象的属性，函数可以用来表示对象的方法
- 继承：lua中的继承是通过元表实现的。可以将一个表的元表设置为另一个表，这样后者的方法和属性就被前者继承了。当访问一个表中不存在的键时，如果这个键在元表中存在，就会返回元表中的值，实现继承的效果
- 多态：函数重载，可以在子表和父表中定义同名的函数，然后根据需要调用不同表中的函数

lua中实现类的实例化：

需要先创建一个table作为类，并设置一个index元方法指向自身，然后提供一个new方法作为构造方法，在方法中重新创建一个空表，并将这个空表的元表设置为需要实例化的类。接着就可以通过调用这个new方法来实现对类的实例化



## 28、Monobehaviour是什么

Monobehaviour是unity中的一个基类，用于派生出游戏对象上的脚本组件，可以用于实现游戏对象的行为和功能。其中提供了一系列的回调函数，通过在特点时间点被Unity自动调用实现在不同阶段对游戏对象的操作和控制（如awake、start、update、lateupdate、onenable、ondisable、ondestroy等）。除了这些回调函数，Monobehaviour还提供了一些常用的功能，如协程、事件监听等，可以实现复杂的游戏逻辑和交互。

总的来说Monobehaviour是unity中用于派生游戏对象脚本组件的基类，通过重写回调函数和使用内部提供的api可以实现游戏对象的行为和功能

## 29、卡通着色的实现方式

卡通着色的特点是强调物体的边缘和阶梯化的颜色渐变，因此主要通过这两个方面进行实现

首先就是通过描边算法来检测物体的边缘，并对检测到的边缘进行加粗或者上色，然后使用阶梯化的颜色来代替光照计算的结果。

## 30、shader中v2f结构体和appdata结构体的作用是什么

- appdata:  这个结构体主要存储模型的信息，常用于顶点着色器中，表示cpu传递到gpu的顶点数据，包含模型的顶点坐标、法线方向、切线方向、纹理坐标等，这些数据都是由unity自动填充的
- v2f：这个结构体用于片元着色器中，表示从顶点着色器传递到片元着色器的数据，包含顶点着色器计算得到的数据，如顶点位置、法线、纹理坐标等，以及其他需要在片元着色器中使用的数据，如描边信息、光照强度等



## 31、shader中的常用API

- **Tex2D:**
- **UnityObjectToClipPos:**
- **UnityObjectToWorldNormal:**
- **UnityWorldSpaceViewDir:**
- **Clip：**
- **saturate:**
- **pow:**
- **smoothstep：**


## 32、UI框架总结

构建UI框架的话首先需要定义一个UI脚本的基类UIModule，所有的UI脚本都要派生自这个类，并向外提供打开UI界面和隐藏UI界面时的回调方法。

由于UI的类型可能会很多，而且具有不同的功能，还需要一个枚举和一个类来存储UI界面的种类和每个UI界面所具备的信息，一般命名为UIType和UIModuleData，枚举用来定义UI界面的类型，比如说开始界面StartPanel、设置界面SettingPanel、提示框tipPanel等。而UIModule这个类则用来存储UI预制体的名字、打开该界面是否隐藏其他界面的布尔属性、该界面的预制体和type类型等。

然后需要构建UIManager这个UI管理类，通过UIManager管理所有的UI脚本，这个类需要作为一个单例类并向外提供显示UI界面、隐藏UI界面的方法。同时这个类还需要两个容器来存储UI界面的信息，一个数组在初始化的时候用来注册所有的UI界面（后续添加新界面时也需要在该容器中进行注册），一个字典用来存储所有打开过的界面，当调用打开UI界面的方法时，会先去字典中查询该界面是否打开过，如果打开过，则直接调用，如果未打开过，则去数组中查询是否有该界面，如果有该界面，则实例化该界面，并将该UI界面添加到字典中，如果数组中也没有，说明未注册，则需检查初始化时候的数组中是不是忘记添加了。（loading界面较为特殊，因为游戏中所有的loading界面都是同一个，只是打开的时候传入的字符串不同，因此可以单独管理）

在整体的框架搭建完成后，就可以单独的编写每个UI界面的脚本（需要继承UIModule这个基类）并挂载到对应的UI物体上。


## 33、渲染队列

unity中的渲染队列是一种用于管理渲染顺序的机制。渲染队列是一个数字，用于指定渲染顺序，数字越小的对象越先被渲染，默认的渲染队列顺序是Opaque(不透明)、Transparent（透明）、Overlay（覆盖）
## 34、UI在不同设备下的适配

UI的适配主要是布局适配和像素适配两方面。布局适配是为了保证UI整体界面在不同设备分辨率下仍能保持相似的布局，不会出现UI挤在一起或者超出屏幕的现象。像素适配就涉及到UI元素在不同的像素密度下的显示效果，避免UI出现不好的显示效果

实现UI适配需要依靠锚点和轴心，Anchors决定了UI元素的位置和大小随着屏幕尺寸的变化而变化，Pivot决定了UI元素的旋转和缩放中心

布局适配的实现：
- 通过Unity提供的Layout布局系统，如通过VerticalLayoutGroup实现垂直方向的适配，通过HorizontalLayoutGroup实现水平方向的适配。或者是GridLayoutGroup实现适配。这样在不同分辨率下的UI都会保持一个较为合理的布局
- 通过脚本动态控制Canvas Scaler的scaleFactor属性来实现UI布局的适配。这个脚本的逻辑主要是获取当前设备屏幕的宽度和高度，然后用这两个数值分别除以预设的屏幕宽度和高度，得到宽高比例，然后将宽度乘一个较为合理的可调节参数x，高度则乘（1-x），并将两者相加，得到最终的缩放因子并赋值给scaleFactor属性（一般是固定像素大小时使用）
- 使用Scale With Screen Size模式，先设置Reference Resolution参考分辨率，然后选择Screen Match Mode屏幕匹配模式，可以选择更倾向于高度适配还是宽度适配，也可以选择expand或shrink来保证所有UI原色的完整显示（该方式没有上一种方式灵活）

像素适配的实现一般也是通过Canvas Scaler提供的几种适配模式：
- Constant Pixel Size：固定像素大小，UI元素的大小保持不变，不会随屏幕分辨率的变化而变化
- Scale With Screen Size：随屏幕大小缩放，UI元素的大小会根据屏幕分辨率的变化而自动缩放
- Constant Physical Size：固定物理大小，UI元素的物理大小保持不变，不会随屏幕分辨率和设备DPI的变化而改变

## 35、点乘叉乘

点乘是两个向量之间的一种运算，如向量a和向量b的点乘结果为：|a||b|cosθ，即它们的模长乘它们之间夹角的余弦值。
**点乘的结果表示了两个向量在方向上的相似程度**，如果ab向量方向相同，点乘结果为1，方向相反，点乘结果为-1；相互垂直，点乘结果为0.
在游戏开发中，通过点乘可以实现以下功能
- 判断敌人与玩家的前后关系
- 将向量的长度进行归一化就可以求出两个向量之间的角度
- 在shader中通过计算光线向量和物体法线向量的点乘结果来得到光照效果

叉乘也是两个向量之间的一种运算，**两个向量的叉乘结果是一个垂直于原本两个向量所在平面的向量**
在游戏开发中，通过叉乘可以实现以下功能：
- 可以用来判断目标物体在自身的顺时针方向还是逆时针方向，叉乘结果大于0说明敌人在自身顺时针方向，叉乘结果小于0说明敌人在自身的逆时针方向
- 计算平面法向量
- 判断三角面片的朝向
## 36、Xlua热更的优缺点

优点：
- 灵活性高，xlua支持动态加载和执行lua脚本，可以实现灵活的游戏逻辑和交互
- 热更方便，避免了每次修改游戏逻辑都需要重新打包和发布的麻烦

缺点：
- 具有一定的学习成本
- 由于xlua是通过动态加载和执行lua脚本来实现热更新的，所以存在一定的安全性问题
- xlua的热更机制需要在运行时动态加载和执行lua脚本，会对游戏性能产生影响，在一些低端设备上还会出现一些兼容性问题


## 37、渲染流水线

unity的渲染流水线是指图形渲染的处理流程和步骤，描述了从场景中的模型、材质、和光照等数据到最终呈现在屏幕上的图像的过程，主要分为以下几个阶段

- 几何阶段：unity将场景中的模型转换为一组顶点和三角形，这个阶段包括模型的顶点变换、裁剪和投射等操作。在这个阶段还会进行一些基本的顶点计算，如法线计算和切线计算
- 光栅化阶段：在光栅化阶段，unity将三角形转换为屏幕上的像素。这个阶段还会进行一些光栅化相关的计算，如深度计算和模板测试
- 片元阶段：在这个阶段unity对每个像素进行处理，计算最终的颜色值。这个阶段包括片段的着色、纹理采样、光照计算和混合等操作。这个阶段还会进行透明度测试和深度测试
- 输出阶段：这个阶段unity将最终的像素颜色值输出到屏幕上。这个阶段包括颜色缓冲区的写入、深度缓冲区的更新和屏幕显示等操作


## 38、如何在Update函数中查找bug

- 使用Debug.Log
- 使用条件断点
- 使用Profiler性能分析器，可以看到在每一帧中各个函数的执行时间
- 使用单元测试
- 使用assert函数
## 39、如何对游戏进行优化

游戏优化的话较为复杂，需要考虑许多不同的因素，很大程度上可以看作是在空间和时间之间进行权衡，找到一种可以接受的程度来有效的使用这些资源

空间换时间：通过预先计算并存储数据来减少实时计算的需要，从而提高游戏的运行速度。比如通过光照贴图、预渲染图像等

时间换空间：可以减少存储需求，并允许更大的灵活性。如许多游戏会实时生成图形和物理效果，这样可以创建出无法预先计算的复杂和动态场景


具体的一些方式包括：
- 批处理：将多个物体合并为一次单一的渲染调用，减少drawcall
- 减少三角形数量：使用低多边形模型、Lod技术和遮挡剔除来减少三角形数量
- 纹理压缩和合并：通过使用unity的纹理压缩选项和纹理合并工具来对纹理进行压缩合并，减少内存占用和GPU负载
- 使用对象池：实现对游戏对象的复用，减少内存分配和垃圾回收的开销
- 代码优化：避免过多的循环和递归，使用性能高的数据结构和算法，避免频繁的内存分配和销毁
- 资源管理：优化资源加载和写在，避免过多的资源加载和内存占用
- 垃圾回收优化：减少垃圾回收的频率和时间，避免在关键帧上进行垃圾回收


## 40、图形学基础


## 41、设计模式

- 单例模式：单例模式用于确保一个类只有一个实例，并提供全局访问点。在unity开发中单例模式常用于管理全局的资源。如：UIManager、GameManager、ConfigDataManager、AudioManager等
- 管理者模式：通常用于管理和协调游戏中的各个模块和系统，管理者模式将各个模块解耦，使得它们可以独立工作并提供统一的接口供其他模块使用
- 状态模式：用于管理游戏中的状态和状态之间的切换。比如游戏中角色的各种状态的切换就可以通过状态模式进行管理
- 工厂模式：用于创建对象并隐藏创建对象的细节，同时向外部提供统一的接口。工厂模式常用于创建游戏中的角色或其他复杂对象，将对象的创建过程封装，使得代码结构清晰并减少代码耦合
- 观察者模式：用于实现对象之间一对多的依赖关系。当某个事件发生时，所有注册的观察者会收到通知并执行相应的操作。如UGUI中的事件系统就是基于观察者模式实现的


## 42、Unity与c#的关系

c#是使用unity开发游戏时主流使用的编程语言，选择c#作为主要编程语言的原因是：
- c#可以在多平台运行。这使得使用c#开发的unity游戏可以轻松的在多个平台上发布和运行
- c#是一种高性能编程语言，有较好的执行效率和强大的功能，如内存管理、异常处理和类型安全等，提高游戏的开发效率
- c#简单易用，学习门槛较低

## 43、lua与c#的交互

在unity中lua与c#的交互主要通过xlua插件实现。

在lua中调用c#的类时可以加上LuaCallCsharp特性，这样xlua就会生成这个类的适配代码（否则会使用效率较低的反射），然后就可以在Lua中访问C#的代码

如果需要把一个Lua的函数映射到一个C#的自定义委托或者把一个Lua的table映射到c#的接口，这个委托和接口必须添加CSharpCallLua特性



## 44、Anchors和Pivot的区别

Anchors是当前物体在父物体上的固定点，无论父物体如何变换，固定点位置不变
Pivot是物体自身的中心，旋转缩放操作都是围绕重心进行的
anchoredPosition是物体的pivot相对于anchors的位置

## 45、元表的作用

元表是一种特殊的表，用于控制和修改其他表的行为，比如通过_Index元方法来访问其他表、通过_Add元方法来对两个表进行相加操作等。各种元方法给我们提供了很大的灵活性，使我们可以自定义和控制表的行为，如可以通过元表来模拟出面向对象中概念

## 46、UI优化

- 动态UI和静态UI分离：避免动态UI网格合并带动静态UI的网格跟随合并
- 拆分复杂UI：根据每个UI的逻辑和功能拆分成不同的预制体，避免UI过大导致实例化缓慢
- 预加载：在游戏加载进度条时把资源加载到内存中，需要用的时候直接激活
- 字体拆分：把常用字体拆分处理，生成一个新的字体文件
- 滚屏优化：没必要一次加载所有内容，只加载当前屏幕可以显出出来的内容，在运行时动态判断是否有UI元素移出画面并进行回收利用；如果必须在打开时就加载大量的元素，可以使用时间分割策略来优化
- UI显示和关闭的优化：隐藏时移出屏幕或者设置为看不到的层级，显示时移动到默认位置或设置为可以看到的层级
