# 一、C#部分

## **1、struct和class的区别**

在c#中struct和class都可以代表一种数据类型，但是也有很多区别

①类型不同，struct是值类型，创建实例时变量直接存储值，而class是引用类型，创建实例时存储的是对象的引用而不是对象本身

②内存分配不同，struct由于是值类型所以在栈上分配内存，而class由于是引用类型所以在堆上分配内存。由于堆上的内存在过多时会进行GC，所以使用class会产生更多的开销

③默认值不同，class的默认值可以为null，而struct不可以

④继承方式不同，class支持继承和多态，而struct不支持。

综上所述class更为灵活，虽然开销更大但是在内部可以写复杂的逻辑，而且支持继承和多态，所以在数据较大并且复杂的时候，应当使用class，当数据较小并且简单时使用struct

## **2、C#中堆和栈的区别**

堆和栈是两种不同的内存分配方式，栈在编译期间就已经分配好的内存空间，存储着函数的参数、局部变量、值类型和引用类型的引用地址，并且存在着先进后出，后进先出的顺序。
而堆是程序运行期间动态分配的内存空间，其内部是无序的并且空间更大，引用类型被声明时都会存储在堆中，并将其在堆中的引用地址存储在栈上。

## **3、abstract class和interface有什么区别**

- 成员：接口只能包含方法、属性、事件和索引器的签名，不能有具体的实现。抽象类则可以包含非抽象方法，也可以定义非静态的类变量
- 继承：一个类可以实现多个接口，但只能继承一个类，借助接口可以间接实现多继承
- 实例化：都不可以被实例化
- 方法实现：继承接口的类必须实现接口的所有成员；继承抽象类的非抽象类必须实现抽象类中的所有抽象方法
- 修改：接口增加新方法时所有实现该接口的类都必须修改以实现新方法。而抽象类可以添加新的方法并提供默认实现
- 使用场景：如果对象存在多个功能相近且关系紧密的版本，则使用抽象类。如果对象关系不紧密，但是拥有相同的功能则使用接口

## **4、C#中委托是什么？事件是不是一种委托？有什么不同？**

委托是一种类型，可以用于封装一个或者多个方法，并允许将这些方法作为参数传递给其他方法。委托实际上是一种函数指针，可以用于调用方法

事件是一种机制，允许对象在特定条件下触发一个或多个方法。事件通常与委托一起使用，以便事件发生时调用相应的方法

事件对委托进行了封装，只能在其所在的类内部触发，但是可以在类外部增加或删除需要相应的方法，而委托可以在任何地方被调用，降低了安全性

## **5、C#实现多态的过程中overload重载和override重写的区别**

重载和重写具有本质性区别，重载只是说具有相同的方法名，但参数的类型、顺序、数量不同，当调用时会根据传入的参数的类型、顺序和数量来调用相应的方法。参数的重写是指将一个方法在派生类中重新定义其逻辑

## **6、ref和out有什么区别**

在c#中，ref和out都是用来传递方法参数的关键字，可以使我们在方法内部修改参数的值并将修改后的值传回（也就是使值类型具有类似引用类型的效果），但两者之间也存在着区别

使用ref关键字之前必须初始化这个参数，然后在内部对参数进行修改，修改后的值会返回出来。而使用out关键字之前不需要对这个参数进行初始化，但是在方法内部必须对这个参数赋值，修改后的参数同样也会返回出来。

ref和out都可以使值类型变量达到类似引用类型变量的效果，但是ref有进有出，out只出不进

## **7、字符串string str=null和string str=""和string str=string.Empty的区别是什么**

string str=""和string str=string.Empty没有任何区别，都表示在托管堆中开辟一块没有任何内容的区域然后将这块区域的地址赋值给str，都表示一个长度为0的字符串，而string str=null表示没有任何的引用对象

## **8、什么是扩展方法**

在c#中定义扩展方法时，可以为现有类添加新的方法而不需要修改原始类的定义或创建子类，这对于在无法访问原始类的源代码时添加新功能非常有用（但也应尽量避免使用，因为会使代码难以理解和维护）

使用扩展方法时必须满足两个条件
①扩展方法必须定义在静态类中
②扩展方法的第一个参数指定要扩展的类型，并且要用this关键字标识

例：

```c#
public static class MyClassExtensions
{
    public static void MyMethod(this MyClass myClass,int x)
      {
         //这里实现MyMethod的逻辑    
      }
}
MyClass myObject=new MyClass();
myObject.MyMethod(10);
```

## **9、as和is的区别**

is关键字用于类型之间的检查，如果检查的两个类型一致那么返回true否则返回false，as关键字用于类型之间的转换，如果转换成功则返回转换后的对象，否则返回null

## **10、string和stringBuilder的区别，两者性能如何**

string和stringBuilder都表示字符串，但是有显著区别，当一个string类型的变量生成时无法修改除非重新生成一个string类型的字符串，而stringBuilder生成的字符串可以进行插入、删除、修改。对于简单的字符串连接操作，在性能上stringBuilder不一定总是优于string，因为stringBuilder对象的创建也会浪费性能，所以在字符串连接较少的情况下滥用stringBuilder会导致性能的浪费而非节约，只有在大量且无法预知次数的字符串操作才考虑stringBuilder的使用

## **11、面向对象的三大特点，请简要叙述**

 面向对象编程是一种编程规范，其三大特点就是封装、继承和多态
 - 封装：封装是指将数据和对数据的操作封装在类中，通过定义外部可访问的接口来控制对内容的访问。封装可以隐藏内部的实现细节，只暴露必要的方法和属性，提高了代码的可维护性和安全性
 - 继承：继承是一种创建新类的方式，新创建的子类可以继承现有父类的属性和方法，并可以添加新的属性和方法或覆盖父类的方法。这样可以实现代码复用，提高开发效率
 - 多态：多态是指一个对象可以以多种形式存在。多态允许我们使用一个抽象的父类类型来引用具体的子类对象，从而实现同样的操作可以根据对象的实际类型而表现出不同的行为。多态性提高了代码的灵活性和可扩展性

多态可以通过继承、接口、抽象类、虚方法、重载等方式实现

## **12、什么是拆装箱，简述其弊端**

在c#中所有类型都继承于object这个最基类，所以所有类型都可以向上转型为object类，当实现某一功能不确定需要传入什么类型的参数时，可以使用object代替，如果传入的类型是值类型时，会发生装箱操作，然后将转换后的object类型在转换回值类型时，会发生拆箱操作，但是在装箱和拆箱的过程会带来性能的开销，这是拆装箱的弊端之一，第二就是存在类型不安全的问题，因为编译器无法在编译期间判断转换的类型和原有类型是否兼容，所以在运行期间可能会异常报错。

为避免这两种弊端，c#提供了一种更好的解决方式，即泛型，因为在泛型中，类型参数在编译期间就确定了，所以编译器可以在编译期间检查类型的安全性，并且泛型还能够提高代码的重用性和性能，所以在能使用泛型解决问题的情况下应该尽量避免拆装箱。

## **13、拆装箱的内存原理**

```
int i=123;
object o=i;
int j=(int)o;
```

上面的代码是一个简单的拆装箱过程，在这个过程中首先执行int i=123,由于i是值类型，所以会在栈中开辟一块内存存储123，然后执行第二段代码，object o=i；由于i是值类型，object是引用类型，所以会先将i的数据拷贝一份，然后在堆中开辟一块内存将拷贝的数据写入堆中，同时将这块内存区域的引用传递给对象o。接着执行第三段代码，由于j是值类型，o是引用类型，所以需要进行强制性转换，此时会将堆中存储的数据拷贝一份，然后拷贝进栈中。

## **14、常规容器和泛型容器有什么区别**

①类型安全性：泛型容器是类型安全的，它在编译器就能够检测到类型错误，因此可以避免运行时出现类型不匹配的错误。而常规容器由于是以object类型作为存储元素的元素，所以可以存储任意类型的数据，这就无法避免的存在数据类型不安全的问题

②性能：泛型容器的性能更好，因为泛型容器可以直接存储值类型数据，而常规容器则需要将值类型装箱未引用类型，导致额外的性能开销

③使用方式：泛型容器需要在创建对象时指定要存储的数据类型，这样能够在编译期检查类型错误，而常规容器不需要。

常规容器：

- ArrayList：动态数组，可以存储任何类型的对象。
- Hashtable：基于哈希表的字典，可以存储键值对。
- Queue：先进先出的队列，可以存储任何类型的对象。
- Stack：后进先出的栈，可以存储任何类型的对象。

泛型容器：

- List：动态数组，可以存储特定类型的对象。
    
- Dictionary<TKey, TValue>：基于哈希表的字典，可以存储键值对。
    
- Queue：先进先出的队列，可以存储特定类型的对象。
    
- Stack：后进先出的栈，可以存储特定类型的对象
## **15、请简述GC产生的原因，并描述如何避免**
   
GC是.Net平台的内存管理机制，作用就是管理内存，避免内存泄漏和溢出。当一个对象不再被使用时就会被标记为是垃圾，当对象的数量到达阈值时，就会触发GC，对这些垃圾进行清理

避免GC频繁触发的方式有以下：
- 显示释放资源：使用完对象后，及时调用释放资源的方法，比如关闭文件、释放连接等。
- 避免创建过多的临时对象：可以通过对象池对对象进行回收利用，避免频繁的创建和销毁
- 事件订阅和取消订阅：如果没有取消订阅，事件的发布者会持有订阅者的引用，导致订阅者无法被垃圾回收
- 尽量使用值类型：值类型在栈上分配内存，而引用类型在堆上分配内存。能用值类型替代的尽可能使用值类型

## **16、数列1，1，2，3，5，8，13......第n位数是多少？用c#递归算法实现**

```c#
 public static int Fibonacci(int n)

{

    if (n <= 0)

    {

        throw new ArgumentException("n must be greater than 0");

    }

    if (n == 1 || n == 2)

    {

        return 1;

    }

    return Fibonacci(n - 1) + Fibonacci(n - 2);

}
```

## **17、如何实现一个方法多个返回值**

可以使用out参数。通过在参数列表添加多个out参数，然后在方法内部为这些参数赋值，当方法返回时，这些参数的值会被传递给调用方

例：

```c#
public void GetValues（out int x,out int y)

{

x=1;

y=1;

}

int a,b;

GetValues(out a,out b )
```

## **18、简述二分查找**

二分查找的前提是已经排好顺序的一列元素（这里假设从小到达）；首先记录中间元素、最大元素和最小元素，然后判断查找元素和中间元素的大小关系，如果查找元素大于中间元素，则更新最小元素下标为中间元素下标+1，然后在新的数列中重复此操作，直到找到该元素

## **19、C#的匿名函数出现在哪些场景**

C#中的匿名函数是一种没有函数名的函数，它可以在程序运行时动态地创建和调用。C#中的匿名函数出现在许多场景中，以下是其中几个重要的场景：

1. 事件处理：C#中的事件机制允许在某个事件发生时执行一段代码（委托），通常使用匿名函数来简化代码。例如：

```cs
button1.Click += (sender, e) => MessageBox.Show("Button clicked!");
```

2. LINQ查询：C#中的LINQ查询可以通过Lambda表达式、匿名委托等方式实现，其中匿名函数是一种常见的方式。例如：

```cs
var result = list.Where(n => n % 2 == 0);
```

3. 异步编程：C#中的异步编程通常使用Async/Await语法糖实现，其中可以使用匿名函数来定义异步方法。例如：

```cs
async Task<int> GetDataAsync()
{
    return await Task.Run(() => DataService.GetData());
}
```

4. 委托：匿名函数可以被用作参数传递给委托，进而被用于回调函数。例如：

```cs
public delegate void SimpleDelegate();
public void RunDelegate(SimpleDelegate simpleDelegate)
{
    simpleDelegate();
}
RunDelegate(() => Console.WriteLine("Hello, world!"));
```

总之，匿名函数广泛应用于事件处理、LINQ查询、异步编程、委托等许多场景中，可以大大简化代码编写和提高程序的可读性和易用性。

## **20、介绍一下static关键字**

static关键字含义为静态，可以修饰类、成员变量和成员方法，修饰类的时候一般用于创建工具类，修饰成员变量或者方法时代表该变量/方法可以被这个类的所有对象共享，一处更改，其他对象都可以感知。调用方式是通过类名调用，静态的变量或者方法随着类的加载而生成，并且优先于对象生成（当创建一个类的实例时，会先将这个类的静态成员加载进静态内存区，然后才会在堆中存储实例并将引用赋值到栈中）

## **21、单例模式有什么用？该怎么实现？**

在面向对象编程中，会遇到某一个类只希望实例化一个对象的情况，这时候就可以使用单例类，此时全局只能实例出一个此类的对象，就比如moba类游戏中的地图，在每次的游戏过程中只需要创建一张地图即可，所以可以写成单例类。

单例类的实现方法是：

①私有构造函数，防止外部new对象

②创建一个私有静态变量用来存储唯一的实例

③属性访问器，提供唯一的获取该实例的途径

例：

```
class Map
{
    private Map(){}
    private static Map instance;
    public static Map Instance
    {
       get
        {
           if(instance==null)
              {
                 instance=new Map();
              }
           return instance;
        }
    }
}
```

## 22、排序算法和二分查找

**冒泡：两两对比，顺序错误就调换**

**选择：从未排序序列中选择最小或者最大的，然后放到已排序序列末尾或者开头，然后从剩余未排序选择最小或最大，放到已排序序列末尾或开头**

**插入：将第一个元素堪为已排序的，从第二个元素开始与已排序元素比较，找到位置插入，如果当前元素小于已排序的某个元素，就后移然后为当前元素腾出插入位置，重复上面步骤，直到排序完成**

**希尔：插入的一种优化版本，原理类似，区别就是将整个序列分为多个子序列，然后对每个子序列进行插入，每个子序列排序完后再进行一次插入就完成所有排序**

**快速：要用到递归思想，思路就是选择一个基准元素，然后将排序序列分为两个子序列，其中一个子序列的元素都小于基准元素，另一个序列都大于基准元素，然后对再对每个子序列重复上述排序，直到完成**

**二分查找：是在已排序序列中查找某个元素，先找出中间位置元素，然后比较中间元素与查找元素，等于说明找到了，查找元素小于中间元素，则以开头为起始，中间元素-1为结尾继续执行，以此类推**

[代码](https://github.com/shishouheng/Unity-learning/blob/main/note/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95.md)

# 二、引擎基础
## **简述游戏动画有几种以及其原理**

主要有关节动画、骨骼动画、单一网格模型动画(关键帧动画)。 单一网格模型动画：由一个完整的网格模型构成，在动画序列的关键帧里记录各个顶点 的 原位置及其改变量，然后插值运算实现动画效果，角色动画较真实。 关节动画：把角色分成若干独立部分，一个部分对应一个网格模型，部分动画 连接成 一 个整体的动画，角色比较灵活； 骨骼动画：广泛应用的动画方式，集成了以上两个方式的优点，骨骼按角色特点组成一 定的层次结构，有关节相连，皮肤作为单一网格蒙在骨骼之外，决定角色的外观。

## **值类型和引用类型的区别？**

值类型：struct 占用内存较小，一般存储在栈中，值类型数据由编译器自主释放，效率 高、速度快； 引用类型：class 占用内存较大，存储在堆中，引用类型由GC调用释放，效率低、速度 慢； 一般来说开发者把一些频繁释放的较小的数据定义为struct，那些生命周期较长数据量较 大 的定义为class。

## **3、NGUI与UGUI的区别？**

UGUI 的Canvas 有世界坐标 和屏幕坐标；NGUI 只有世界坐标； UGUI 通过Mask进行裁剪；但是NGUI 通过Panel 的Clip； NGUI 的渲染顺序 是通过Widget中的深度决定，而UGUI是通过在层级面板的渲染顺序 决定，越靠下越先被渲染； UGUI 不需要绑定碰撞器，可以自动拦截事件，NGUI 需要 自行绑定 碰撞器； UGUI的锚点是相对于 父物体的，没有提供其他选项，NGUI 的锚点 相对的目标是可以 自行设置的。 NGUI 有比较强大的动画系统等。

## **4、Image和RawImage的区别？**

Imgae比RawImage更消耗性能； Image只能使用Sprite属性的图片，但是RawImage什么样的都可以使用； Image适合放一些有操作的图片，平铺、九宫格、裁剪等（Image Type）； RawImage放单独展示的图片即可，性能会比Image好很多 。

## **5、简述你对协同程序的理解，什么情况下时候协同程序？**

协同程序其本质是迭代器，核心语法是用yiled return 关键字，在特定时间返回 IEnumerator的接口对象； 在unity里主要用来做延迟，延迟帧数，延迟时间，延迟到某个方法执行之后，延迟到某 个行为结束等； 它运行与主线程，在一帧update之后进行判断，当yield return语法会挂起，当条件满 足时会继续往下执行，是对多线程支持不足的一种替代方案。 
a、用来延时； 
b、用来异步加载等待； 
c、加载WWW； 
d、控制代码在特定的时机执行。

## **6、如何实现UI界面的多屏幕适配?**

在界面实际运行与不同的屏幕中时，基于设计分辨率的高度进行等比缩放，这样可以保 证UI各个控件的比例不变。 如果拉伸后出现UI显示不完整的情况可以通过调整相机的正交大小来改变。 多出的黑边 一般采用挡板的形式来进行控，当然，也可以直接使用UGUI中的锚点对各个 控件进行父子节点的绑定来控制显示位置。

## **7、为什么 Unity3D 中会发生在组件上出现数据丢失的情况？**

有可能是组件所挂载的游戏物体被销毁掉了。

## **8、如何安全的在不同工程间安全地迁移 Assets 数据？三种方法；**

a、将Assets目录和Library目录一起迁移； 
b、导出包； 
c、用unity自带的assets Server功能

## **9、请简述GC（垃圾回收）产生的原因，并描述如何避免？**

 GC是一种自动的内存管理机制，用于释放程序中不再使用的内存，产生的原因是程序运行时动态分配内存，当不再需要某个对象时，如果程序没有显示的释放该对象所占用的内存，那么这块内存就会被认为是垃圾，当到达阈值时会开启GC的过程。

①可以通过对象池减少对象创建和销毁的过程

②减少对象的分配，对象分配会触发GC

③使用结构体代替类，结构体是值类型，在栈上分配内存而不是在堆上，这样就不会触发GC

④手动调用GC.Collect进行垃圾回收

## **10、当一个细小的高速物体撞向另一个较大的物体时，会出现什么情况？如何避免？**

会发生穿透现象，小物体直接穿过大物体，这是因为在物理模拟中，碰撞检测和相应都是以离散的时间步长进行的，无法准确处理高速撞击的情况

可以通过增加物体的碰撞检测精度来避免或者将物体的碰撞器调整厚一些

## **11、资源动态加载到内存的几种方式？**

a、从Resources文件夹中加载，Resources.Load； 
b、从某个特定地址加载资源；www 一般是异步加载； 
c、File类型加载文件 File.ReadAllBytes File.ReadAllText等。

## **12、u3d 中碰撞器和触发器的区别？**

触发舍去了碰撞的效果，保留了碰撞的数据信息。

## **13、CharacterController 和 Rigidbody 的区别？**

刚体是真实的物理模拟，包含重力、质量、物理材质等等物理相关属性，但是物理计算 消耗比较大； 角色控制器也包含碰撞信息和重力自适应，是一种简化的刚体。 如果项目中只是为了让游戏物体具有一些基本的物理效果，比如人物 推荐使用 CharacterController 。

## **14、什么叫做链条关节？**

Hinge Joint ，他可以模拟两个物体间用一根链条连接在一起的情况，能保持两个物体在 一个固定距离内部相互移动而不产生作用力， 但是达到固定距离后就会产生拉力。 （简单说就是弹簧）

## **15、什么是序列化？**

序列化简单理解成把对象转换为容易传输的格式的过程。 比如，可以序列化一个对象， 然后在客户端和服务器端之间传输该对象 。

## **16、什么是导航网格（ NavMesh）？**

导航网格用于描述游戏中可行走的表面，允许在游戏中寻找从一个可行位置到另一个可行位置的路径，实现游戏角色的自动寻路

## **17、string str=null与string str2="" 有什么区别；**

string str=null 字符串的内容为空值； 
string str=“” 为其赋值。 
string str=null与string str=“” 区别 
1. ""分配了内存；null没有分配内存。 
2. 区别 2. ""是一个字符串(String).它在内存中是存在的.而null它是一个空对象.在内存中是 不存在 的。 
3. 区别3. ""占内存，在内存中会分配一个空间；null不占内存. 为空引用。

## **18、Unity3d脚本从唤醒到销毁有着一套比较完整的生命周期，请列出系统自带的几个 重要的方法。**

Awake——>OnEnable–>Start——>Update——>FixedUpdate——>LateUpdate—— >OnGUI——>OnDisable——>OnDestroy

## **19、面向对象和面向过程的区别以及优缺点？**

面向过程式分析出解决问题的步骤，然后一步一步实现，在使用时分步调用； 
面向对象是把问题分解成各个对象，建立的对象并不是为了完成一个步骤，而是描述一 种行为。 
面向过程： 优点：性能高 ； 
缺点：不易维护 不易复用 不易扩展 。 
面向对象： 
优点：易维护 易复用 以扩展 更加灵活； 
缺点：性能低，类调用是需要实例化，开销比较大，消耗资源 。

## **20、C#遇到泛型底层是如何编译的？**

生成模板。 值类型 每个值类型调用时都为其创建一个模板，以后再次调用直接使用创建好的那个； 引用类型生成的是object类型的模板 为通用模板


# 三、 引擎中级

## **1、简述unity中实现延迟操作的几种方式**

- 使用协程配合yield return可以实现延迟一帧，延迟一定时间和延迟到一个固定的节点。
- Invoke和InvokeRepeating实现方法延迟调用
- 使用Time.DeltaTime在Update中累加实现自定义延迟

## **2、Unity的新版动画比老版动画增加了哪些功能**

- 增加了人形骨骼humanoid实现动画重定向
- 增加了Animator动画控制器，可以在编辑界面上实现对动画的切换和混合

## **3、如何实现动画的倒播**

把动画播放的起始位置放在最后一帧，然后将动画的播放速度设置为负数

## **4、实现人物向前跳跃有哪些方式**

- 使用跟运动模式（Root Motion）动画实现人物位置的变更
- 使用插值搭配三角函数来实现角色从起始位置以抛物线形式跳跃到目标位置
- 使用Unity的物理系统，通过向前方施加力的方式进行控制


## **5、用Switch实现状态机有什么问题？简述FSM状态机的实现流程**

用switch实现的状态机存在代码臃肿、逻辑混乱、耦合性强、不易维护的缺点

FSM状态机的实现流程是首先实现基础的状态父类，封装状态的一些虚函数（如进入状态、状态初始化、状态更新、状态退出等）

然后让每一个状态的脚本都继承并实现该父类

最后配合管理者模式实现状态机的管理类，负责对各个状态进行存储、切换、移除、获取等，并在系统中缓存一个当前的状态对象，切换状态时直接修改状态对象的指向即可

## **6、简述AStar寻路算法的实现原理**

Astar算法是一种在图形和网格中寻找最短路径的算法。实现原理是：

- 将所有的位置信息通过一个一个的网格表示
- 创建一个开启列表和一个关闭列表，分别存储等待检查的方格和不需要检查的方格
- 将起点放入开启列表，遍历其周围所有方格并放入开启列表中同时将起点作为它们的父方格，计算每个方格的靠谱度（估价函数）:F=G+H（G表示从起点移动到当前方格的距离，H表示从当前方格移动到终点的距离，移动方式可以根据需求自行设置）
- 将开启列表中F值最低的方格从开启列表删除并放入关闭列表中，接着重复上面的步骤遍历该方格周围的所有方格并计算它们的F值（障碍物和已经在关闭列表中的不需要考虑），如果未在开启列表中则放入开启列表。（如果某个相邻方格已经在开启列表中，则计算通过新的路径到达它所得到的G值是否会更低，如果更低则设置其父方格为当前方格）
- 重复上面的步骤直到终点出现在开启列表中
- 找回路径，所有的父方格就是路径

## **7、使用Navigation系统进行场景烘焙前需要做好哪些准备工作**

将需要烘焙的物体设置为导航静态，并设置好导航代理的参数

## **8、Unity中使用多线程开发需要注意什么？如何解决**

Unity不能在分线程调用unity的API，解决方案是使用时间分割策略，如协程

## **9、写出AssetBundle的函数和参数列表**

1.BuildPipeline.BuildAssetBundles(string outputPath,BuildAssetBundleOptions options,BuildTarget targetPlatform)
- outputPath:AssetBundle的输出路径
- options:AssetBundle的构建选项，可以指定是否压缩、是否包含依赖项等
- targetPlatform：AssetBundle的目标平台，可以是Android、IOS、Windows等

2.AssetBundle.LoadFromFile(string path)
- path:AssetBundle的文件路径，可以是相对路径或绝对路径

3.AssetBundle.LoadFromMemory(byte[]binary)
- binary:AssetBundle的二进制数据
## **10、使用WWW加载StreamingAssets文件夹的资源时需要注意什么？**

- 在不同平台下StreamingAssets的路径是不同的
- www类加载数据时不会立即返回结果，而是在数据加载完成后返回结果，而资源加载又需要时间，因此需要搭配协程使用，避免阻塞主线程

## **11、为什么要使用Assetbundle.UnLoad(bool)进行卸载？如何理解参数中bool的作用**

AssetBundle下载完成后 本地会生成一个内存镜像文件 在资源加载完成后会把资源加入到缓存中 Unload是卸载函数 可以用来协程镜像文件或者是通过load所加载的缓存资源 bool为false 仅卸载镜像文件 bool为true 则卸载镜像文件和load加载的资源 如果资源一直加载但是不卸载 会导致内存中涵盖大量的垃圾 如果内存不足 则导致效率下降 出现运行缓慢的问题

## **12、代码实现C#单例抽象父类模板**
```c#
public abstract class Singleton<T> where T : new()
{
    private static T ms_instance;

    protected Singleton() { }

    public static T Instance
    {
        get
        {
            if (ms_instance == null)
            {
                ms_instance = new T();
            }

            return ms_instance;
        }
    }
}

```


## **13、详细描述 Unity为什么要选择C#进行跨平台游戏开发?**

1. 跨平台性：C#是一种面向对象的编程语言，它的跨平台性非常好。Unity引擎本身是跨平台的，可以在多个操作系统上运行，包括Windows、Mac、Linux、iOS、Android等。通过使用C#作为脚本语言，可以在不同平台上共享和重用代码，减少开发人员在不同平台上的工作量。
    
2. 强大的生态系统：C#是一种非常流行的编程语言，在开发社区中有大量的资源和工具可用。Unity作为一个广泛使用的游戏引擎，有庞大的开发者社区和丰富的插件生态系统。使用C#可以更方便地与这些资源和工具进行集成和交互，加速游戏开发的进程。
    
3. 性能和可扩展性：C#是一种高性能的编程语言，具有良好的执行效率和内存管理机制。Unity引擎使用了Mono运行时环境来解释和执行C#脚本，它的性能表现非常出色。另外，C#还提供了很多高级特性和库，可以方便地实现游戏中的各种功能和效果，提高开发效率和游戏性能。
    
4. 开发效率：C#是一种简洁、易读、易学的编程语言，具有很强的可读性和可维护性。它支持面向对象的编程范式，并提供了很多高级特性，如委托、事件、LINQ等，能够简化开发过程，提高代码的可重用性和可扩展性。同时，Unity提供了丰富的API和工具，可以快速开发各种游戏功能，加速开发进程。


## 14、unity中协程与线程的区别

在unity中，协程与线程是两种不同的并发执行方式（即在同一时间执行多个指令序列）

线程是操作系统提供的基本执行单元，可以独立运行在不同的处理器核心上，并且不会阻塞主线程，可以用于执行耗时操作，在unity中可以使用system.Threading命名空间的Thread类来创建和管理线程，但是Unity中的大部分API只能在主线程调用，

而协程是基于时间分割策略实现的一种轻量级的线程，本质上还是在主线程执行。
协程是通过迭代器+yield return关键字实现的，将需要在一帧内完成的任务分布到多个帧内完成，有效避免了同一帧执行任务过多而可能导致的卡顿现象

迭代器的作用是返回容器中的数据，那unity中的协程为什么可以实现暂停执行和继续执行呢？

unity为我们提供了一些封装好的迭代器对象，如WaitForSeconds、WaitForEndOfFrame等等，这些类都实现了IEnumerator接口，并且在内部会记录当前时间与等待时间，同时会在每一帧更新时间，

当我们通过StartCoroutine开启一个协程后，这个协程会挂在Monobehaviour下，并在Update和LateUpdate之间检查这个Monobehaviour下面的所有协程，并唤醒满足条件的协程

当协程开启执行到yield return xxx时，会将一个迭代器返回出去，然后在每一帧判断是否到达设定的时间，如果到达就执行下一步操作，没到达就继续在下一帧进行检查，以此实现协程的暂停与开启



## 15.什么是三次握手

三次握手是建立TCP连接的过程，它需要客户端和服务器总共发送3个包以确认连接的建立

- 第一次握手：客户端向服务器发送一个SYN包，并等待服务器确认。发送完毕后，客户端进入SYN_SENT状态，等待服务器确认
- 第二次握手：服务器收到SYN包后，会向客户端发送一个SYN+ACK包确认连接请求。此时服务器进入SYN_RCVD状态
- 第三次握手：客户端收到SYN+ACK包后，会向服务器发送一个ACK包。发送完毕后客户端进入ESTABLISHED状态。服务器收到ACK包后也进入这个状态

完成以上三次握手后，TCP连接就建立成功了，客户端和服务器就可以开始数据传输


## 