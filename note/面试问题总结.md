
# C#基础

## 1.struct和class的区别

在c#中struct和class都可以代表一种数据类型，但是也有很多区别

①类型不同，struct是值类型，创建实例时变量直接存储值，而class是引用类型，创建实例时存储的是对象的引用而不是对象本身

②内存分配不同，struct由于是值类型所以在栈上分配内存，而class由于是引用类型所以在堆上分配内存。由于堆上的内存在过多时会进行GC，所以使用class会产生更多的开销

③默认值不同，class的默认值可以为null，而struct不可以

④继承方式不同，class支持继承和多态，而struct不支持。

综上所述class更为灵活，虽然开销更大但是在内部可以写复杂的逻辑，而且支持继承和多态，所以在数据较大并且复杂的时候，应当使用class，当数据较小并且简单时使用struct

## 2.C#中堆和栈的区别

堆和栈是两种不同的内存分配方式，栈在编译期间就已经分配好的内存空间，存储着函数的参数、局部变量、值类型和引用类型的引用地址，并且存在着先进后出，后进先出的顺序。
而堆是程序运行期间动态分配的内存空间，其内部是无序的并且空间更大，引用类型被声明时都会存储在堆中，并将其在堆中的引用地址存储在栈上。

## 3.abstract class和interface有什么区别

- 成员：接口只能包含方法、属性、事件和索引器的签名，不能有具体的实现。抽象类则可以包含非抽象方法，也可以定义非静态的类变量
- 继承：一个类可以实现多个接口，但只能继承一个类，借助接口可以间接实现多继承
- 实例化：都不可以被实例化
- 方法实现：继承接口的类必须实现接口的所有成员；继承抽象类的非抽象类必须实现抽象类中的所有抽象方法
- 修改：接口增加新方法时所有实现该接口的类都必须修改以实现新方法。而抽象类可以添加新的方法并提供默认实现
- 使用场景：如果对象存在多个功能相近且关系紧密的版本，则使用抽象类。如果对象关系不紧密，但是拥有相同的功能则使用接口

## 4.C#中委托是什么？事件是不是一种委托？有什么不同？

委托是一种类型，可以用于封装一个或者多个方法，并允许将这些方法作为参数传递给其他方法。委托实际上是一种函数指针，可以用于调用方法

事件是一种机制，允许对象在特定条件下触发一个或多个方法。事件通常与委托一起使用，以便事件发生时调用相应的方法

事件对委托进行了封装，只能在其所在的类内部触发，但是可以在类外部增加或删除需要相应的方法，而委托可以在任何地方被调用，降低了安全性

## 5.C#实现多态的过程中overload重载和override重写的区别

重载和重写具有本质性区别，重载只是说具有相同的方法名，但参数的类型、顺序、数量不同，当调用时会根据传入的参数的类型、顺序和数量来调用相应的方法。参数的重写是指将一个方法在派生类中重新定义其逻辑

## 6.ref和out有什么区别

在c#中，ref和out都是用来传递方法参数的关键字，可以使我们在方法内部修改参数的值并将修改后的值传回（也就是使值类型具有类似引用类型的效果），但两者之间也存在着区别

使用ref关键字之前必须初始化这个参数，然后在内部对参数进行修改，修改后的值会返回出来。而使用out关键字之前不需要对这个参数进行初始化，但是在方法内部必须对这个参数赋值，修改后的参数同样也会返回出来。

ref和out都可以使值类型变量达到类似引用类型变量的效果，但是ref有进有出，out只出不进

## 7.字符串string str=null和string str=""和string str=string.Empty的区别是什么

string str=""和string str=string.Empty没有任何区别，都表示在托管堆中开辟一块没有任何内容的区域然后将这块区域的地址赋值给str，都表示一个长度为0的字符串，而string str=null表示没有任何的引用对象

## 8.什么是扩展方法

在c#中定义扩展方法时，可以为现有类添加新的方法而不需要修改原始类的定义或创建子类，这对于在无法访问原始类的源代码时添加新功能非常有用（但也应尽量避免使用，因为会使代码难以理解和维护）

使用扩展方法时必须满足两个条件
①扩展方法必须定义在静态类中
②扩展方法的第一个参数指定要扩展的类型，并且要用this关键字标识

例：

```c#
public static class MyClassExtensions
{
    public static void MyMethod(this MyClass myClass,int x)
      {
         //这里实现MyMethod的逻辑    
      }
}
MyClass myObject=new MyClass();
myObject.MyMethod(10);
```

## 9.as和is的区别

is关键字用于类型之间的检查，如果检查的两个类型一致那么返回true否则返回false，as关键字用于类型之间的转换，如果转换成功则返回转换后的对象，否则返回null

## 10.string和stringBuilder的区别，两者性能如何

string和stringBuilder都表示字符串。
string在每次拼接时都会产生垃圾，而stringBuilder拼接时是在原空间进行修改，不会产生垃圾，会自动帮我们扩容。所以当字符串需要频繁修改拼接时使用StringBuilder。

## 11.面向对象的三大特点，请简要叙述

 面向对象编程是一种编程规范，其三大特点就是封装、继承和多态
 - 封装：封装是指将数据和对数据的操作封装在类中，通过定义外部可访问的接口来控制对内容的访问。封装可以隐藏内部的实现细节，只暴露必要的方法和属性，提高了代码的可维护性和安全性
 - 继承：继承是一种创建新类的方式，新创建的子类可以继承现有父类的属性和方法，并可以添加新的属性和方法或覆盖父类的方法。这样可以实现代码复用，提高开发效率
 - 多态：多态是指可以使用一个通用的类型来表示特定的子类型，比如当一个类继承自另一个类时，并且重写了父类的某个方法，我们可以通过父类的引用来调用子类中重写的方法，实现同一个方法名根据对象的实际类型不同调用不同的实现。多态性提高了代码的灵活性和可扩展性

多态可以通过继承、接口、抽象类、虚方法、重载等方式实现

## 12.什么是拆装箱，简述其弊端

在c#中所有类型都继承于object这个最基类，所以所有类型都可以向上转型为object类，当实现某一功能不确定需要传入什么类型的参数时，可以使用object代替，如果传入的类型是值类型时，会发生装箱操作，然后将转换后的object类型在转换回值类型时，会发生拆箱操作，但是在装箱和拆箱的过程会带来性能的开销，这是拆装箱的弊端之一，第二就是存在类型不安全的问题，因为编译器无法在编译期间判断转换的类型和原有类型是否兼容，所以在运行期间可能会异常报错。

为避免这两种弊端，c#提供了一种更好的解决方式，即泛型，因为在泛型中，类型参数在编译期间就确定了，所以编译器可以在编译期间检查类型的安全性，并且泛型还能够提高代码的重用性和性能，所以在能使用泛型解决问题的情况下应该尽量避免拆装箱。

## 13.拆装箱的内存原理

```
int i=123;
object o=i;
int j=(int)o;
```

上面的代码是一个简单的拆装箱过程，在这个过程中首先执行int i=123,由于i是值类型，所以会在栈中开辟一块内存存储123，然后执行第二段代码，object o=i；由于i是值类型，object是引用类型，所以会先将i的数据拷贝一份，然后在堆中开辟一块内存将拷贝的数据写入堆中，同时将这块内存区域的引用传递给对象o。接着执行第三段代码，由于j是值类型，o是引用类型，所以需要进行强制性转换，此时会将堆中存储的数据拷贝一份，然后拷贝进栈中。

## 14.常规容器和泛型容器有什么区别

①类型安全性：泛型容器是类型安全的，它在编译器就能够检测到类型错误，因此可以避免运行时出现类型不匹配的错误。而常规容器由于是以object类型作为存储元素的元素，所以可以存储任意类型的数据，这就无法避免的存在数据类型不安全的问题

②性能：泛型容器的性能更好，因为泛型容器可以直接存储值类型数据，而常规容器则需要将值类型装箱未引用类型，导致额外的性能开销

③使用方式：泛型容器需要在创建对象时指定要存储的数据类型，这样能够在编译期检查类型错误，而常规容器不需要。

常规容器：

- ArrayList：动态数组，可以存储任何类型的对象。
- Hashtable：基于哈希表的字典，可以存储键值对。
- Queue：先进先出的队列，可以存储任何类型的对象。
- Stack：后进先出的栈，可以存储任何类型的对象。

泛型容器：

- List：动态数组，可以存储特定类型的对象。
    
- Dictionary<TKey, TValue>：基于哈希表的字典，可以存储键值对。
    
- Queue：先进先出的队列，可以存储特定类型的对象。
    
- Stack：后进先出的栈，可以存储特定类型的对象
## 15.请简述GC产生的原因，并描述如何避免
   
GC是.Net平台的内存管理机制，作用就是管理内存，避免内存泄漏和溢出。当一个对象不再被使用时就会被标记为是垃圾，当对象的数量到达阈值时，就会触发GC，对这些垃圾进行清理

避免GC频繁触发的方式有以下：
- 显示释放资源：使用完对象后，及时调用释放资源的方法，比如关闭文件、释放连接等。
- 避免创建过多的临时对象：可以通过对象池对对象进行回收利用，避免频繁的创建和销毁
- 事件订阅和取消订阅：如果没有取消订阅，事件的发布者会持有订阅者的引用，导致订阅者无法被垃圾回收
- 尽量使用值类型：值类型在栈上分配内存，而引用类型在堆上分配内存。能用值类型替代的尽可能使用值类型

## 16.数列1，1，2，3，5，8，13......第n位数是多少？用c#递归算法实现

```c#
 public static int Fibonacci(int n)

{

    if (n <= 0)

    {

        throw new ArgumentException("n must be greater than 0");

    }

    if (n == 1 || n == 2)

    {

        return 1;

    }

    return Fibonacci(n - 1) + Fibonacci(n - 2);

}
```

## 17.如何实现一个方法多个返回值

可以使用out参数。通过在参数列表添加多个out参数，然后在方法内部为这些参数赋值，当方法返回时，这些参数的值会被传递给调用方

例：

```c#
public void GetValues（out int x,out int y)

{

x=1;

y=1;

}

int a,b;

GetValues(out a,out b )
```



## 18.C#的匿名函数出现在哪些场景

C#中的匿名函数是一种没有函数名的函数，它可以在程序运行时动态地创建和调用。C#中的匿名函数出现在许多场景中，以下是其中几个重要的场景：

1. 事件处理：C#中的事件机制允许在某个事件发生时执行一段代码（委托），通常使用匿名函数来简化代码。例如：

```cs
button1.Click += (sender, e) => MessageBox.Show("Button clicked!");
```

2. LINQ查询：C#中的LINQ查询可以通过Lambda表达式、匿名委托等方式实现，其中匿名函数是一种常见的方式。例如：

```cs
var result = list.Where(n => n % 2 == 0);
```

3. 异步编程：C#中的异步编程通常使用Async/Await语法糖实现，其中可以使用匿名函数来定义异步方法。例如：

```cs
async Task<int> GetDataAsync()
{
    return await Task.Run(() => DataService.GetData());
}
```

4. 委托：匿名函数可以被用作参数传递给委托，进而被用于回调函数。例如：

```cs
public delegate void SimpleDelegate();
public void RunDelegate(SimpleDelegate simpleDelegate)
{
    simpleDelegate();
}
RunDelegate(() => Console.WriteLine("Hello, world!"));
```

总之，匿名函数广泛应用于事件处理、LINQ查询、异步编程、委托等许多场景中，可以大大简化代码编写和提高程序的可读性和易用性。

## 19.介绍一下static关键字

static关键字含义为静态，可以修饰类、成员变量和成员方法，修饰类的时候一般用于创建工具类，修饰成员变量或者方法时代表该变量/方法可以被这个类的所有对象共享，一处更改，其他对象都可以感知。调用方式是通过类名调用，静态的变量或者方法随着类的加载而生成，并且优先于对象生成（当创建一个类的实例时，会先将这个类的静态成员加载进静态内存区，然后才会在堆中存储实例并将引用赋值到栈中）

## 20.单例模式有什么用？该怎么实现？

在面向对象编程中，会遇到某一个类只希望实例化一个对象的情况，这时候就可以使用单例类，此时全局只能实例出一个此类的对象，就比如moba类游戏中的地图，在每次的游戏过程中只需要创建一张地图即可，所以可以写成单例类。

单例类的实现方法是：

①私有构造函数，防止外部new对象

②创建一个私有静态变量用来存储唯一的实例

③属性访问器，提供唯一的获取该实例的途径

例：

```c#
class Map
{
    private Map(){}
    private static Map instance;
    public static Map Instance
    {
       get
        {
           if(instance==null)
              {
                 instance=new Map();
              }
           return instance;
        }
    }
}
```

## 21.面向对象和面向过程的区别以及优缺点？

面向过程式分析出解决问题的步骤，然后一步一步实现，在使用时分步调用； 
面向对象是把问题分解成各个对象，建立的对象并不是为了完成一个步骤，而是描述一 种行为。 
面向过程： 优点：性能高 ； 
缺点：不易维护 不易复用 不易扩展 。 
面向对象： 
优点：易维护 易复用 以扩展 更加灵活； 
缺点：性能低，类调用是需要实例化，开销比较大，消耗资源 。

## 22.C#遇到泛型底层是如何编译的？

生成模板。 值类型,每个值类型调用时都为其创建一个模板，以后再次调用直接使用创建好的那个； 引用类型生成的是object类型的模板 为通用模板

## 23.请简述GC（垃圾回收）产生的原因，并描述如何避免？

 GC是一种自动的内存管理机制，用于释放程序中不再使用的内存，产生的原因是程序运行时动态分配内存，当不再需要某个对象时，如果程序没有显示的释放该对象所占用的内存，那么这块内存就会被认为是垃圾，当到达阈值时会开启GC的过程。

①可以通过对象池减少对象创建和销毁的过程

②减少对象的分配，对象分配会触发GC

③使用结构体代替类，结构体是值类型，在栈上分配内存而不是在堆上，这样就不会触发GC

④手动调用GC.Collect进行垃圾回收


## 24.代码实现C#单例抽象父类模板
```c#
public abstract class Singleton<T> where T : new()
{
    private static T ms_instance;

    protected Singleton() { }

    public static T Instance
    {
        get
        {
            if (ms_instance == null)
            {
                ms_instance = new T();
            }

            return ms_instance;
        }
    }
}

```

## 25.简述Sealed用在类声明和函数声明时的作用

当sealed关键字修饰类的时候，其他类不能继承这个sealed类

当sealed关键字修饰函数时，必须与override一起使用，此时该类的派生类无法重写此虚方法

## 26.反射是什么？是怎么实现的？

反射是一种机制，允许程序在运行时动态地获取类型信息、访问和操作对象地属性、方法和事件等。反射提供了一组类和方法，使得程序可以在运行时通过代码分析和操作其他程序集、类型和对象。

反射可以在运行期间获取类型信息是因为C#编译器在编译时会将源代码转换为IL中间语言，其中包含了完整的类型信息，在程序运行期间CLR会将IL转换为机器码并执行，同时也会提供反射API让开发者在运行时访问和操作这些类型信息

## 27.程序集是什么？元数据是什么？

程序集是C#中用来打包代码和资源的一种方式，是一种包含了代码和相关资源的文件。程序集中的代码是编译后的，可以直接被.net环境执行。常见的两种程序集有exe文件和dll文件

元数据是一种描述程序集、类型和成员信息的结构化数据。通过元数据可以了解程序集中包含的类型以及这些类型的成员和特性


元数据是描述程序的信息，而程序集是包含了程序的代码和元数据的文件


## 28.值类型和引用类型在变量赋值时的区别

- 值类型：当把一个值类型变量赋值给另一个值类型变量时，实际是创建了一个新的副本，改变一个变量的值不会影响另一个变量
- 引用类型：当把一个引用类型变量赋值给另一个引用类型变量时，实际是复制了对象的引用而非对象本身，意味着两个变量指向同一个对象，修改一个变量另一个变量也会被影响

## 29.委托和事件在使用上的区别

- 调用权限：委托可以在任何地方被调用，而事件只能在声明它的类中被触发
- 赋值操作：委托可以用=来进行赋值，事件只能用+=或-=来添加或移除方法
- 封装性：事件提供了更好的封装性，在外部只能订阅或移除事件，而不能触发事件，委托则没有这样的限制

## 30.有两个接口IA和IB，它们中有一个同名方法Test，一个类同时继承这两个接口，会如何处理它们的同名方法

可以在方法前加上接口的名称，然后用点号连接方法名来指定这个方法是实现哪一个接口的


## 31.C#中 == 和 Equals 的区别是什么

- 值类型：对于值类型来说== 和Equals的作用是一致的，都是比较它们的值是否相等
- 引用类型：== 比较的是它们的引用是否相等；而Equals用于判断两个对象的内容是否一样

## 32.finally块的执行顺序

不管是否有异常都会在执行完finally块后再执行return语句

## 33.泛型的约束有哪几种

- T:struct:值类型约束
- T:class:引用类型约束
- T:new():公共无参构造约束
- T:类名：类约束
- T:接口名：接口约束
- T:U:另一个泛型约束

## 34.内存泄漏是指什么？有哪些常见的内存泄漏？

内存泄漏指对象超过生命周期后由于某些操作而不能被GC回收，一直占用着内存，最终导致内存耗尽。
常见的导致内存泄漏的操作有：
- 静态引用
- 不使用的引用对象没有置null，一直被引用
- 文件操作后没有Dispose
- 委托或事件注册后没有解除引用


## 35.C#中如何让自定义容器类能够使用for循环遍历？

可以在该类中通过实现索引器实现

## 36.如果给两个字符串对象赋相同的值，那它们会在堆中分配几块内存

会分配一块，虽然string是引用类型，但CLR对字符串进行了优化，当创建字符串时，CLR会检查字符串暂存池中是否存在相同内容的字符串，如果存在，就会返回暂存池中的对象而不是创建新的对象。

但对于其他引用类型，即使赋了相同的值，它们在堆中的地址也是不一样的

## 37.泛型的好处有哪些

- 提升性能，避免了拆装箱的操作
- 提升代码的复用性，使不同类型的对象可以进行通用处理

## 38.内存抖动指什么？如何避免内存抖动？

内存抖动指短时间有大量的对象被创建或者被回收的现象，频繁的内存抖动会造成GC频繁运行，影响性能。

可以通过对象池或享元模式避免

## 39.如何用一个int变量，记录32种状态

int再c#种占4个字节，32位，可以按位记录状态，每一位代表一个状态，1为存在，0为不存在

## 40.什么是线程安全，如何在C#中实现线程安全操作

线程安全是指在多线程环境中，对共享资源进行操作时，不会产生不正确的结果或者不可预期的行为，避免发生数据损坏、竟态条件和其他错误

可以通过使用锁或者异步编程的方式实现线程安全


## 41.属性和字段的区别

属性一般用于封装字段，提供更多的控制和逻辑，相比直接访问字段，通过属性可以实现在访问字段的过程中添加验证、计算等逻辑

## 42.介绍一下C#中的异步编程

异步编程是一种用于处理并发任务的技术，在执行异步操作时，程序可以继续执行其他任务并且不会阻塞主线程。对于处理网络请求、文件读写等耗时操作时非常有用


# Unity

## 1.简述游戏动画有几种以及其原理

主要有关节动画、骨骼动画、单一网格模型动画(关键帧动画)。 单一网格模型动画：由一个完整的网格模型构成，在动画序列的关键帧里记录各个顶点 的 原位置及其改变量，然后插值运算实现动画效果，角色动画较真实。 关节动画：把角色分成若干独立部分，一个部分对应一个网格模型，部分动画 连接成 一 个整体的动画，角色比较灵活； 骨骼动画：广泛应用的动画方式，集成了以上两个方式的优点，骨骼按角色特点组成一 定的层次结构，有关节相连，皮肤作为单一网格蒙在骨骼之外，决定角色的外观。


## 2.简述你对协同程序的理解，什么情况下时候协同程序？

协同程序是一种时间分割策略来，其本质是迭代器，核心语法是用yiled return 关键字，在特定时间返回 IEnumerator的接口对象； 在unity里主要用来做延迟，延迟帧数，延迟时间，延迟到某个方法执行之后，延迟到某 个行为结束等； 它运行与主线程，在一帧update之后进行判断，当yield return语法会挂起，当条件满 足时会继续往下执行，是对多线程支持不足的一种替代方案。 
a、用来延时； 
b、用来异步加载等待； 
c、加载WWW； 
d、控制代码在特定的时机执行。

## 3.为什么 Unity3D 中会发生在组件上出现数据丢失的情况？

有可能是组件所挂载的游戏物体被销毁掉了。

## 4.如何安全的在不同工程间安全地迁移 Assets 数据？三种方法

a、将Assets目录和Library目录一起迁移； 
b、导出包； 
c、用unity自带的assets Server功能



## 5.当一个细小的高速物体撞向另一个较大的物体时，会出现什么情况？如何避免？

会发生穿透现象，小物体直接穿过大物体，这是因为在物理模拟中，碰撞检测和相应都是以离散的时间步长进行的，无法准确处理高速撞击的情况

可以通过增加物体的碰撞检测精度来避免或者将物体的碰撞器调整厚一些

## 6.资源动态加载到内存的几种方式？

a、从Resources文件夹中加载，Resources.Load； 
b、从某个特定地址加载资源；www 一般是异步加载； 
c、File类型加载文件 File.ReadAllBytes File.ReadAllText等。

## 7.u3d 中碰撞器和触发器的区别？

触发舍去了碰撞的效果，保留了碰撞的数据信息。

## 8.CharacterController 和 Rigidbody 的区别？

刚体是真实的物理模拟，包含重力、质量、物理材质等等物理相关属性，但是物理计算 消耗比较大； 角色控制器也包含碰撞信息和重力自适应，是一种简化的刚体。 如果项目中只是为了让游戏物体具有一些基本的物理效果，比如人物 推荐使用 CharacterController 。

## 9.什么叫做链条关节？

Hinge Joint ，他可以模拟两个刚体间用一根链条连接在一起的情况，能保持两个物体在 一个固定距离内部相互移动而不产生作用力， 但是达到固定距离后就会产生拉力。 （简单说就是弹簧）



## 10.什么是导航网格（ NavMesh）？

导航网格用于描述游戏中可行走的表面，允许在游戏中寻找从一个可行位置到另一个可行位置的路径，实现游戏角色的自动寻路



## 11.Unity3d脚本从唤醒到销毁有着一套比较完整的生命周期，请列出系统自带的几个 重要的方法

Awake——>OnEnable–>Start——>Update——>FixedUpdate——>LateUpdate—— >OnGUI——>OnDisable——>OnDestroy





## 12.简述unity中实现延迟操作的几种方式

- 使用协程配合yield return可以实现延迟一帧，延迟一定时间和延迟到一个固定的节点。
- Invoke和InvokeRepeating实现方法延迟调用
- 使用Time.DeltaTime在Update中累加实现自定义延迟

## 13.Unity的新版动画比老版动画增加了哪些功能

- 增加了人形骨骼humanoid实现动画重定向
- 增加了Animator动画控制器，可以在编辑界面上实现对动画的切换和混合

## 14.如何实现动画的倒播

把动画播放的起始位置放在最后一帧，然后将动画的播放速度设置为负数

## 15.实现人物向前跳跃有哪些方式

- 使用跟运动模式（Root Motion）动画实现人物位置的变更
- 使用插值搭配三角函数来实现角色从起始位置以抛物线形式跳跃到目标位置
- 使用Unity的物理系统，通过向前方施加力的方式进行控制


## 16.用Switch实现状态机有什么问题？简述FSM状态机的实现流程

用switch实现的状态机存在代码臃肿、逻辑混乱、耦合性强、不易维护的缺点

FSM状态机的实现流程是首先实现基础的状态父类，封装状态的一些虚函数（如进入状态、状态初始化、状态更新、状态退出等）

然后让每一个状态的脚本都继承并实现该父类

最后配合管理者模式实现状态机的管理类，负责对各个状态进行存储、切换、移除、获取等，并在系统中缓存一个当前的状态对象，切换状态时直接修改状态对象的指向即可

## 17.简述AStar寻路算法的实现原理

Astar算法是一种在图形和网格中寻找最短路径的算法。实现原理是：

- 将所有的位置信息通过一个一个的网格表示
- 创建一个开启列表和一个关闭列表，分别存储等待检查的方格和不需要检查的方格
- 将起点放入开启列表，遍历其周围所有方格并放入开启列表中同时将起点作为它们的父方格，计算每个方格的靠谱度（估价函数）:F=G+H（G表示从起点移动到当前方格的距离，H表示从当前方格移动到终点的距离，移动方式可以根据需求自行设置）
- 将开启列表中F值最低的方格从开启列表删除并放入关闭列表中，接着重复上面的步骤遍历该方格周围的所有方格并计算它们的F值（障碍物和已经在关闭列表中的不需要考虑），如果未在开启列表中则放入开启列表。（如果某个相邻方格已经在开启列表中，则计算通过新的路径到达它所得到的G值是否会更低，如果更低则设置其父方格为当前方格）
- 重复上面的步骤直到终点出现在开启列表中
- 找回路径，所有的父方格就是路径

## 18.使用Navigation系统进行场景烘焙前需要做好哪些准备工作

将需要烘焙的物体设置为导航静态，并设置好导航代理的参数

## 19.Unity中使用多线程开发需要注意什么？如何解决

Unity不能在分线程调用unity的API，解决方案是使用时间分割策略，如协程


## 20.使用WWW加载StreamingAssets文件夹的资源时需要注意什么

- 在不同平台下StreamingAssets的路径是不同的
- www类加载数据时不会立即返回结果，而是在数据加载完成后返回结果，而资源加载又需要时间，因此需要搭配协程使用，避免阻塞主线程






## 21.详细描述 Unity为什么要选择C#进行跨平台游戏开发?

1. 跨平台性：C#是一种面向对象的编程语言，它的跨平台性非常好。Unity引擎本身是跨平台的，可以在多个操作系统上运行，包括Windows、Mac、Linux、iOS、Android等。通过使用C#作为脚本语言，可以在不同平台上共享和重用代码，减少开发人员在不同平台上的工作量。
    
2. 强大的生态系统：C#是一种非常流行的编程语言，在开发社区中有大量的资源和工具可用。Unity作为一个广泛使用的游戏引擎，有庞大的开发者社区和丰富的插件生态系统。使用C#可以更方便地与这些资源和工具进行集成和交互，加速游戏开发的进程。
    
3. 性能和可扩展性：C#是一种高性能的编程语言，具有良好的执行效率和内存管理机制。Unity引擎使用了Mono运行时环境来解释和执行C#脚本，它的性能表现非常出色。另外，C#还提供了很多高级特性和库，可以方便地实现游戏中的各种功能和效果，提高开发效率和游戏性能。
    
4. 开发效率：C#是一种简洁、易读、易学的编程语言，具有很强的可读性和可维护性。它支持面向对象的编程范式，并提供了很多高级特性，如委托、事件、LINQ等，能够简化开发过程，提高代码的可重用性和可扩展性。同时，Unity提供了丰富的API和工具，可以快速开发各种游戏功能，加速开发进程。


## 22.unity中协程与线程的区别

在unity中，协程与线程是两种不同的并发执行方式（即在同一时间执行多个指令序列）

线程是操作系统提供的基本执行单元，可以独立运行在不同的处理器核心上，并且不会阻塞主线程，可以用于执行耗时操作，在unity中可以使用system.Threading命名空间的Thread类来创建和管理线程，但是Unity中的大部分API只能在主线程调用，

而协程是基于时间分割策略实现的一种轻量级的线程，本质上还是在主线程执行。
协程是通过迭代器+yield return关键字实现的，将需要在一帧内完成的任务分布到多个帧内完成，有效避免了同一帧执行任务过多而可能导致的卡顿现象

迭代器的作用是返回容器中的数据，那unity中的协程为什么可以实现暂停执行和继续执行呢？

unity为我们提供了一些封装好的迭代器对象，如WaitForSeconds、WaitForEndOfFrame等等，这些类都实现了IEnumerator接口，并且在内部会记录当前时间与等待时间，同时会在每一帧更新时间，

当我们通过StartCoroutine开启一个协程后，这个协程会挂在Monobehaviour下，并在Update和LateUpdate之间检查这个Monobehaviour下面的所有协程，并唤醒满足条件的协程

当协程开启执行到yield return xxx时，会将一个迭代器返回出去，然后在每一帧判断是否到达设定的时间，如果到达就执行下一步操作，没到达就继续在下一帧进行检查，以此实现协程的暂停与开启


## 23.yield关键字原理

yield关键字是一个语法糖，可以帮助我们快速的创建迭代器。yield return可以根据返回值类型是IEnumerable还是IEnumerator来告诉编译器创建的是可枚举类型还是枚举器，并且指定了枚举器的下一个可枚举选项。它的原理是通过编译器生成一个状态机来实现的，这个状态机具有四个状态：
- Before：首次调用MoveNext方法前的位置，在第一个可枚举项之前
- Running：调用MoveNext后进入该状态，在该状态使迭代器会检测下一项的位置是否有效，当遇到yield return时会进入到挂起状态并返回yield return 后面的值作为当前枚举型
- Suspend：挂起状态，等待下一次MoveNext调用时唤醒
- End：结束位置，没有可枚举项了

## 24.Unity与c#的关系

c#是使用unity开发游戏时主流使用的编程语言，选择c#作为主要编程语言的原因是：
- c#可以在多平台运行。这使得使用c#开发的unity游戏可以轻松的在多个平台上发布和运行
- c#是一种高性能编程语言，有较好的执行效率和强大的功能，如内存管理、异常处理和类型安全等，提高游戏的开发效率
- c#简单易用，学习门槛较低


## 25.Unity中的线程有什么用

线程是操作系统中的一个概念，是进程中的实际运作单位，一个进程可以包含若干个线程。

在unity中子线程是指运行于主线程之外的线程。Unity的主线程主要复杂处理游戏的渲染和更新逻辑。子线程则可以用于处理一些耗时的计算、加载资源、网络请求等操作，避免阻塞主线程。

需要注意的是在Unity中子线程不能执行Unity提供的API，但是可以考虑通过在子线程将任务添加到一个执行队列中，然后在主线程执行这个队列来间接实现调用Unity的API

总之，在unity开发中，使用子线程可以处理耗时的操作，避免阻塞主线程，提高游戏的性能和响应性


## 26.同步方法和异步方法的区别

同步方法和异步方法的区别在于它们的执行方式和对线程的使用

同步方法：
- 同步方法是按顺序依次执行的，每个方法执行完成后才会执行下一个方法
- 同步方法会阻塞当前线程，直到方法执行完成后才会继续执行下一个操作
- 同步方法适用于需要按照顺序执行的操作，或者不需要额外的线程来执行任务的情况

异步方法：
- 异步方法是可以同时执行的，不需要等待上一个方法执行完成
- 异步方法可以可以在后台线程中继续执行，不会阻塞主线程
- 异步方法适用于需要同时执行多个任务或者执行耗时操作的情况

使用场景：
- 同步方法适用于简单的操作，不涉及到耗时任务并需要按照特定顺序执行。
- 异步方法适用于需要执行耗时操作的情况，如加载大量资源、网络请求、复杂计算等。

在unity中可以使用协程实现异步操作，也可以使用async/await语法来实现异步操作

## 27.Monobehaviour是什么

Monobehaviour是unity中的一个基类，用于派生出游戏对象上的脚本组件，可以用于实现游戏对象的行为和功能。其中提供了一系列的回调函数，通过在特点时间点被Unity自动调用实现在不同阶段对游戏对象的操作和控制（如awake、start、update、lateupdate、onenable、ondisable、ondestroy等）。除了这些回调函数，Monobehaviour还提供了一些常用的功能，如协程、事件监听等，可以实现复杂的游戏逻辑和交互。

总的来说Monobehaviour是unity中用于派生游戏对象脚本组件的基类，通过重写回调函数和使用内部提供的api可以实现游戏对象的行为和功能


## 28.如何将分线程的数据同步到主线程

- 队列：可以在子线程中创建一个任务，并将这个任务添加到一个线程安全的队列中。然后再主线程中按照一定的频率检查这个队列，如果队列中有任务，就去执行这个任务
- 使用委托：在分线程完成数据处理后，可以将需要在主线程中执行的操作封装成委托，并通过主线程中的回调函数来进行数据的同步

## 29.如何在Update函数中查找bug

- 使用Debug.Log
- 使用条件断点
- 使用Profiler性能分析器，可以看到在每一帧中各个函数的执行时间
- 使用单元测试
- 使用assert函数
## 30.如何对游戏进行优化

游戏优化的话较为复杂，需要考虑许多不同的因素，很大程度上可以看作是在空间和时间之间进行权衡，找到一种可以接受的程度来有效的使用这些资源

空间换时间：通过预先计算并存储数据来减少实时计算的需要，从而提高游戏的运行速度。比如通过光照贴图、预渲染图像等

时间换空间：可以减少存储需求，并允许更大的灵活性。如许多游戏会实时生成图形和物理效果，这样可以创建出无法预先计算的复杂和动态场景


具体的一些方式包括：
- 批处理：将多个物体合并为一次单一的渲染调用，减少drawcall
- 减少三角形数量：使用低多边形模型、Lod技术和遮挡剔除来减少三角形数量
- 纹理压缩和合并：通过使用unity的纹理压缩选项和纹理合并工具来对纹理进行压缩合并，减少内存占用和GPU负载
- 使用对象池：实现对游戏对象的复用，减少内存分配和垃圾回收的开销
- 代码优化：避免过多的循环和递归，使用性能高的数据结构和算法，避免频繁的内存分配和销毁
- 资源管理：优化资源加载和写在，避免过多的资源加载和内存占用
- 垃圾回收优化：减少垃圾回收的频率和时间，避免在关键帧上进行垃圾回收


## 31.Application.streamingAssetsPath 和 Application.persistentDataPath两个路径有何区别？对于我们的意义是什么？

- Application.streamingAssetPath:只读路径，通常存储一些外部数据文件，如AssetBundle、csv等。这个路径下的文件跟随Unity打包存在，且不会被加密
- Application.persistentDataPath:可读写路径，通常用于存储需要在运行时保存和修改的数据，如玩家的游戏数据。该路径在游戏安装成功后创建，无法在打包前将文件放入路径


## 32.Unity底层如何处理C#代码

Unity底层是通过Mono运行时来处理C#代码的（Mono是一个跨平台的开源实现，实现了C#和.NET框架的规范，可以在多个平台运行C#代码）

当在Unity中编写C#代码时，Unity会将代码编译为IL中间语言，然后通过Mono运行时将中间语言转换为本地机器码，最终在目标平台上执行

## 33.Prefab的本质是什么

Prefab的本质就是一个配置文件，记录了GameObject对象上挂载的脚本信息，并且记录了脚本信息中的可配置的属性信息


## 34.Unity引擎中的哪些功能使用了C#的反射功能

- Inspector窗口显示的内容
- 预设体文件
- 场景文件
- Unity中的各种特性

## 35.Unity中Awake和Start两个生命周期函数，分别在什么时候被调用？

- Awake：游戏运行时当脚本被动态添加到对象上时立即被调用，当对象被实例化时，依附它的脚本会立即调用Awake，类似于构造函数
- Start：在第一次Update之前被调用

## 36.如何控制不同脚本之间Awake的执行顺序

可以通过Execution Order来设置脚本的执行顺序


## 37.Unity中的输入事件（如鼠标、键盘、触摸屏等）是在Update之前还是之后还是同时进行的

是在update之前执行的，unity的输入系统会在每一帧开始前，先处理输入事件，然后再执行update函数。这样可以保证再update函数中处理输入时能够获取到最新的输入状态

## 38.unity中的lerp和slerp分别是什么

- Lerp：线性插值函数，接受三个参数：起始值、目标值和插值系数，可以在两个值之间进行平滑的线性插值
- Slerp：球面插值函数，接受三个参数：起始值、目标值和插值系数，Slerp在插值过程中会在两个旋转之间进行曲线插值，保持自然的旋转过渡


## 39.1000个Monobehaviour，每个各自执行update和放到一个update里执行，哪个效率更高？

放在一个update里效率更好，
- 每调用一次update，相当于执行了一次方法，而每一次方法的调用都是有开销的。
- Unity内部对生命周期函数采用了引用和查找机制，每次调用update时也会存在查找相关操作，会增加部分开销

## 40.Unity中写代码时有什么常用的优化代码性能手段

- 在更新函数中尽量使用临时变量
- 在切换场景时手动调用GC
- 尽量少用浮点数，用乘法代替除法
- 对象池
- 尽量减少update的数量

## 41.LOD和Mipmap是用来做什么的，有什么优缺点

LOD是多层次细节，即按照模型的位置和重要程度决定物体渲染所需的资源分配，降低不重要物体的面数和细节，从而获得高效率的渲染

Mipmap是预先计算和优化过的图片组成的贴图文件，可以加快渲染进度并减少图形锯齿

这两种方式都是根据和相机的距离来确定不同的模型和贴图的细节程度，从而降低渲染的面数或者图片细节，获得高效的渲染效率，缺点是都会增加内存


## 42.为什么说Unity是一款面向组件编程的游戏引擎

这其实是一个引擎的设计问题，因为在大多数的现代游戏引擎中，游戏中的每一个物体都可以用GameObject来表示，如果我们用传统的面向对象的思想来思考，假设我们有一个船的基类和一个坦克的基类，现在策划突然有一个实现水陆两栖工具的需求，那这个工具到底是属于船类还是坦克类呢？用面向对象的方式就很难得到答案，但是我们可以进行抽象，将属于船的属性和行为的部分抽象成一个组件，然后让这个新的道具去继承这个船和坦克的组件，这样就有了一个符合逻辑的设计，并且实现了高度的模块化和定制化，并且减少了耦合性，我们还可以抽象出更多的组件，如飞机组件，潜水组件，策划想要啥功能，直接就添加对应组件即可。

## 43.面向组件编程和面向对象编程各有什么优缺点

组件化设计与完全的面向对象设计各有优缺点，具体的适用场景和实际需求会影响到哪种设计方法更合适。以下是它们各自的优缺点：

### 组件化设计的优缺点

#### 优点

1. **高灵活性**：
    
    - **动态组合**：组件化设计允许对象在运行时动态组合和拆分功能，提供更大的灵活性。这在需要频繁更改对象行为或特性时特别有用，例如在游戏开发中，角色可以在运行时获得新的技能或装备。
2. **代码复用性高**：
    
    - **模块化功能**：将常用功能封装成独立的组件，可以在不同的对象之间共享。这减少了代码重复，提高了复用性。例如，一个“飞行”组件可以同时用于“飞机”和“超人”两个类。
3. **低耦合性**：
    
    - **减少继承复杂度**：通过避免深层的继承结构，组件化设计可以减少系统的耦合性和复杂度，使系统更容易理解和维护。
4. **易扩展性**：
    
    - **添加新功能简单**：要添加新功能时，只需开发新的组件并将其组合到现有对象中，无需修改现有的类结构。这使得系统的扩展性非常强。

#### 缺点

1. **复杂性**：
    
    - **系统管理复杂**：组件化设计可能导致系统中有大量的独立组件，需要管理它们的组合关系。这会增加设计和调试的难度，特别是在组件数量较多的情况下。
2. **性能开销**：
    
    - **组件组合的开销**：由于对象的行为是通过多个组件组合而成的，这可能会带来额外的性能开销，尤其是在组件间需要频繁通信时。
3. **难以追踪对象行为**：
    
    - **行为分散**：组件化设计中，对象的行为可能分散在多个组件中，这使得追踪和理解一个对象的整体行为变得困难，增加了调试和维护的难度。

### 完全面向对象设计的优缺点

#### 优点

1. **结构清晰**：
    
    - **继承层次明确**：通过清晰的继承层次，面向对象设计能够很好地组织代码，使系统结构清晰、易于理解。类的行为和属性通常定义在一个地方，方便追踪和管理。
2. **自然的对象建模**：
    
    - **类的自然扩展**：面向对象设计能够直观地将现实世界的实体建模为类，通过继承和多态实现自然的扩展。这在需求变化不大的情况下非常有效。
3. **封装性强**：
    
    - **数据和行为封装**：面向对象设计将数据和行为封装在类中，提供了良好的封装性，能够很好地隐藏内部实现细节，只暴露必要的接口。
4. **低开销**：
    
    - **直接调用**：类的方法和属性通常是直接调用的，这相比组件化设计中的动态组合有更低的性能开销，尤其是在类层次结构较浅的情况下。

#### 缺点

1. **灵活性不足**：
    
    - **继承的刚性**：继承关系在系统设计时就确定了，后续如果需求发生变化，需要修改类的继承结构，这可能导致大量的重构工作。
2. **代码复用受限**：
    
    - **继承层次深**：如果类层次过深，复用性可能会受到限制，因为子类通常只能从单一的父类继承行为和属性。多重继承虽然可以部分解决这个问题，但也会增加系统复杂度和引入潜在问题（如菱形继承问题）。
3. **继承层次复杂**：
    
    - **管理难度**：在复杂的系统中，深层次的继承关系可能会使得代码难以管理和理解，尤其是在层次结构过深的情况下。
4. **扩展性差**：
    
    - **增加新功能困难**：如果需要给类添加新功能，往往需要修改已有类或创建新的子类，这可能导致代码膨胀和维护困难，特别是在需求变化频繁的情况下。

### 什么时候使用哪种设计？

- **使用组件化设计**：当需求变化频繁、系统需要高灵活性和易扩展性时，组件化设计更为适合。例如，游戏开发、复杂用户界面系统、或任何需要动态组合功能的场景。
    
- **使用完全面向对象设计**：当系统需求稳定、类的层次结构明确且继承关系清晰时，完全面向对象设计更为适合。例如，传统业务应用、简单的几何建模系统、或继承关系稳定的场景。
    

### 综合考虑

实际开发中，往往会结合使用两者的优势。即使在一个传统的面向对象系统中，也可以通过组件化设计引入部分灵活性，或者通过继承提供基本的功能抽象。通过结合使用这两种方法，你可以设计出既灵活又高效的系统。

4o

# Lua
## 1.lua实现面向对象的原理

lua本身没有面向对象的概念，但是可以通过元表和元方法来模拟出类似面向对象的特性。

- 封装：在Lua中封装可以直接用表来实现，用一个表代表一个对象，表中的字段来表示对象的属性，函数可以用来表示对象的方法
- 继承：lua中的继承是通过元表和元方法实现的。可以将一个表的元表设置为另一个表，这样后者的方法和属性就被前者继承了。当访问一个表中不存在的键时，如果这个键在元表中存在，就会返回元表中的值，实现继承的效果
- 多态：函数重载，可以在子表和父表中定义同名的函数，然后根据需要调用不同表中的函数

lua中实现类的实例化：

需要先创建一个table作为类，并设置一个index元方法指向自身，然后提供一个new方法作为构造方法，在方法中重新创建一个空表，并将这个空表的元表设置为需要实例化的类。接着就可以通过调用这个new方法来实现对类的实例化

## 2.Lua的迭代器有哪些？怎么实现？

lua中的迭代器分为无状态迭代器和多状态迭代器。

无状态迭代器不需要保存当前的迭代位置，每次调用都会从头开始遍历，如ipairs和pairs就是无状态迭代器，每次调用都会自动的从第一个元素开始迭代到最后一个元素，不会记录当前的迭代位置

ipairs与pairs都是无状态迭代器，它们的区别是ipairs只能遍历数组，并且必须是连续的，如果序列不连续就会返回nil，而pairs可以用于遍历任何表

多状态迭代器需要记录当前的迭代位置，每次调用都会从上一次结束的地方继续遍历，通过保存多个状态信息，我们可以更好地控制迭代器的行为和逻辑，在处理复杂情况时具有更大的灵活性，（如遍历一个嵌套的表）lua中没有提供默认的多状态迭代器，但是可以通过闭包实现多状态迭代器


## 3.Lua中_index和_newindex元方法的区别

`_newindex`用于表的更新，`index`用于表的查询
- 如果访问不存在的数据，由`_index`提供最终结果
- 如果对不存在的数据赋值,由`_newindex`对数据进行赋值

`_index`元方法可以是一个函数也可以是一个表，当访问一个表中不存在的字段时，并且该表的元表具有`_index`字段。如果`_index`包含一个表，lua会在这个表中查找相应的键，如果`_index`是一个函数，则lua会调用这个函数，并将表和键作为参数传入
`_newindex` 当试图修改一个表中不存在的字段时，并且该表的元表具有`_newindex`字段。如果`_newindex`是一个表，则lua会在这个表中创建新的键值对，如果`_newindex`是一个函数，则lua会调用这个函数，并将表、键和值作为参数传入


## 4.Lua中元表的作用

为一个表设置元表后，运行该表的行为关联元方法

## 5.Lua协程是什么？进行信息传递的过程是怎样的

lua中的协程类似于Unity中的协程，都可以通过yield关键字实现在函数执行的过程中暂停并在一定的时间后继续执行的功能。

- coroutine.create()：创建一个协程
- coroutine.resume()：启动/恢复协程，并传递一个值作为协程的返回值
- coroutine.yield()：暂停协程的执行并返回一个值
- coroutine.status()：获取协程的状态，包括running、suspended、dead

在lua中，协程可以通过coroutine.resume和coroutine.yield函数来交换信息
- 当第一次调用coroutine.resume来启动协程时，所有传递给resume的参数都会作为协程主函数的参数
- 当协程主函数运行到coroutine.yield时，该函数的返回值会成为coroutine.resume的返回值

## 6.说说Lua中的闭包

闭包是由一个函数和该函数会访问到的非局部变量组成的。非局部变量指既不是局部变量也不是全局变量的一个变量。主要用在嵌套函数或匿名函数中，可以用于实现多状态迭代器

```lua
function Fun1(a)
	local x=a
	--闭包，改变了传入参数的生命周期
	return function(y)
		print(x+y)  
	end
end

B=Fun1(5) --此时B就是Fun1中返回的函数
B(4)  --输出9
```


## 7、如何实现多状态迭代器

多状态迭代器可以通过闭包来实现，由于多状态迭代器在每次调用时都会更新内部状态，如当前索引，因此可以添加额外的逻辑进行一些判断或依据某些条件来实现我们所需要的功能，所以相对来说会更加的灵活
```lua
array = {"Google", "Runoob"}

function elementIterat，or(collection)
    local index = 0
    local count = #collection
    -- 闭包函数
    return function()
        index = index + 1
        if index <= count then
            -- 返回迭代器的当前元素
            return collection[index]
        end
    end
end

for element in elementIterator(array) do
    print(element)
end

```


## 8、Lua协程与Unity协程的区别

Unity使用了C#的迭代器和yield关键字来实现协程，而Lua中的协程是语言本身提供的

它们的相同点有：
- 都有挂起和恢复的操作，并且都是通过yield关键字进行挂起
- 都可以在主线程和协程之间传递数据

不同点有：
- Unity的协程的更依赖于Unity引擎对其生命周期的管理，而Lua中的协程更加灵活，可以手动控制其生命周期
- Lua没有提供一些预设的行为，使用比较灵活但不够方便


## 9.Lua中不使用require能否访问到其它脚本内的方法

- loadfile：加载一个指定路径的lua脚本文件，但不执行。这个函数返回一个编译好的函数，可以在需要的时候调用这个函数来执行脚本
- dofile：类似于loadfile，但是在加载脚本后会立即执行它
- load：加载一个字符串形式的代码块，但不执行它。该函数返回一个编译好的函数，可以在需要的时候调用这个函数来执行代码块

## 10.什么是深拷贝什么是浅拷贝，如何实现深拷贝

深拷贝和浅拷贝是两种常见的复制对象的方式

对于浅拷贝，直接用=运算符就是浅拷贝，此时分两种情况
- 拷贝对象是string、number、bool基本类型时，拷贝的过程就是复制粘贴，修改一个不会影响原先对象的值
- 拷贝对象是table表，此时拷贝出来的对象和原先对象是同一个对象，占用同一块内存，类似于C#中的引用地址，任意一方修改都会影响另一方

深拷贝需要使用特定的函数如DeepCopy或Clone实现，深拷贝会创建一个新的对象，并且该对象的元素是原始对象的副本。这意味着即使修改了原始表，新对象中的元素也不会改变

## 11.Lua中的table是什么，可以做什么？

lua中table是唯一的数据结构，可以创建不同的数据类型，如数组和字典。Lua使用关联数组（关联数组是一种数据结构，每个元素都通过唯一的键来表示和访问，而不是通过连续的整数索引），可以使用任意类型的值来作为数组的索引。

# 热更新

## 1.写出AssetBundle的函数和参数列表

1.BuildPipeline.BuildAssetBundles(string outputPath,BuildAssetBundleOptions options,BuildTarget targetPlatform)
- **outputPath**:AssetBundle的输出路径
- **options**:AssetBundle的构建选项，可以指定是否压缩、是否包含依赖项等
- **targetPlatform**：AssetBundle的目标平台，可以是Android、IOS、Windows等

2.AssetBundle.LoadFromFile(string path)
- path:AssetBundle的文件路径，可以是相对路径或绝对路径

3.AssetBundle.LoadFromMemory(byte[]binary)
- binary:AssetBundle的二进制数据

## 2.AssetBundle有哪些压缩格式

-  `BuildAssetBundleOptions.UncompressedAssetBundle:` 不对AssetBundle进行压缩，资源较大，加载较快
- `BuildAssetBundleOptions.None:` 默认的LZMA格式压缩，是能将资源压缩最小的方式，同样加载时间也是最长的
- `BuildAssetBundleOptions.ChunkBasedCompression:` 基于块的LZ4压缩方式，相比LZMA压缩方式会稍大一下，但是加载速度更快，因为LZ4的解压缩速度较快


## **3.为什么要使用Assetbundle.UnLoad(bool)进行卸载？如何理解参数中bool的作用**

AssetBundle下载完成后 本地会生成一个内存镜像文件 在资源加载完成后会把资源加入到缓存中 Unload是卸载函数 可以用来协程镜像文件或者是通过load所加载的缓存资源 bool为false 仅卸载镜像文件 bool为true 则卸载镜像文件和load加载的资源 如果资源一直加载但是不卸载 会导致内存中涵盖大量的垃圾 如果内存不足 则导致效率下降 出现运行缓慢的问题


## 4.XLua实现Lua与C#交互的原理是什么

xlua实现lua与c#交互是通过使用lua虚拟机实现的，通过这个虚拟机xlua可以将c#中的类和方法暴露给lua，c#中的类和方法可以通过使用CSharpCallLua和LuaCallCSharp特性来进行声明和注册，从而让Lua可以访问它们。

当Lua调用C#中的方法时，xlua会将方法的参数和返回值转换为相应的Lua类型，然后通过Lua虚拟机来执行C#中的方法。**（如果添加了LuaCallCSharp标签，xlua会生成这个类型的适配代码来让lua进行调用，否则就会使用性能较低的反射）**

反之，当C#调用Lua中的函数时，xlua会将C#中的调用转换为Lua的函数调用，并将参数和返回值转换为相应的C#类型。**c#访问lua中的函数或者table，需要在c#中对应的委托或者接口添加CSharpCallLua标签，xlua会生成Bridge文件，并将lua中的函数映射到c#中对应的委托或者接口中，然后通过luaenv.Global来调用**

## 5.Xlua热更的优缺点

优点：
- 灵活性高，xlua支持动态加载和执行lua脚本，可以实现灵活的游戏逻辑和交互
- 热更方便，避免了每次修改游戏逻辑都需要重新打包和发布的麻烦

缺点：
- 具有一定的学习成本
- 由于xlua是通过动态加载和执行lua脚本来实现热更新的，所以存在一定的安全性问题
- xlua的热更机制需要在运行时动态加载和执行lua脚本，会对游戏性能产生影响，在一些低端设备上还会出现一些兼容性问题

## 6.热更新流程

热更新的话分为资源热更和代码热更。在游戏打开的时候会进行一次版本检测，如果发现游戏版本有更新，会自动从服务端请求下载更新的文件。不管是资源还是代码更新都是通过assetbundle打包放到服务端实现的。

对于资源热更，可以直接将需要更新的资源进行标记AssetBundle，然后通过一个BuildAssetbundle脚本对所有的资源进行一个打包，然后上传到服务端即可。并通过资源管理系统中每个资源的标识符来对旧的资源进行替代

对于代码热更，要先对可能会热更的代码添加xlua中的hotfix特性，表面该段代码可能在未来会被热更，然后在lua脚本中确定需要替换的是哪一个被标记了hotfix的代码，然后将该lua脚本打包为assetbundle并上传到服务端，客户端请求下载后就完成了代码的热更新


## 7.如果不考虑IOS平台，只在Windows和Android平台上发布游戏，如何在不使用第三方热更新方案的前提下实现热更新功能

可以通过C#的反射加载程序集并热更DLL包中的逻辑


## 8.AB包分包策略

ab包的大小会影响加载速度，ab包控制在1MB左右可以保证较高的加载效率。通常有如下几种打包策略

- 根据类别打包：将资源类变相同的打包到一起，如图片资源打包到一起、材质球打包到一起，如果单种资源过多，就分成多个包
	- 优点：最为通用，不需要考虑资源用途
	- 缺点：依赖逻辑复杂，可能需要同时加载多个ab包中的资源，导致加载速度缓慢、内存占用高
- 根据用途分类：业务逻辑需要同时加载的资源打包到一起，如一个UI中所有的预制体、图片、材质球都放到一起
	- 优点：加载速度块，使用时不需要加载太多的依赖包，玩家热更下载的ab包大部分都是需要更新的资源
	- 缺点：公用资源较难处理，每种资源放入前都要规划好用途
- 根据更新频率分类：更新频率差不多的资源打包到一起
	- 优点：避免玩家热更时下载过多未更新的资源
	- 缺点：具体分组策略还需要参考上面两种


## 9.AB包的性能优化

ab包可优化的方向有三点：下载速度、加载速度和内存管理
下载速度优化：ab文件进行一定的压缩，然后通过多线程进行下载
加载速度优化：包体的大小不要过大，然后通过加载界面预加载较大的资源
内存管理优化：ab包与资源加载使用后及时卸载，ab包中的依赖不应该过大
# 数据结构和算法

## 1.什么是时间复杂度和空间复杂度

- 空间复杂度：是用来比较不同算法内存效率的一种方式，用来估算算法在处理不同大小的输入数据时所需的内存空间；即描述了算法所需空间如何随着输入大小的增长而变化
- 时间复杂度：是用来比较不同算法效率的一种方式，用来估算算法在处理大小不同的输入数据时，所需的计算步骤数量；即描述了算法执行时间如何随着输入大小的增长而变化

## 2.数据结构及原理

### 线性结构：
所有线性结构的元素都存在着一对一的关系，即除了第一个元素外所有元素都有一个前驱元素，以及除了最后一个元素外所有元素都有一个后继元素
- 数组：最简单的一种线性结构，使用连续的内存空间来存储元素，逻辑意义上相邻的元素在物理空间上也是相邻的，数组分为普通数组、动态数组和泛型动态数组。**数组的插入、删除、按值查找的效率较低，时间复杂度为O(n)，按索引查找效率较高，时间复杂度为O(1)**
- 栈：一种先进后出的数据结构，只允许在栈顶进行插入和删除的操作,**栈的插入和删除效率较高，时间复杂度为O(1)**
- 队列：一种先进先出的数据结构，允许在队尾插入元素在队首删除元素,**队列的插入和删除效率较高，时间复杂度为O(1)**
- 链表：由节点组成的数据结构，每个节点除了存储数据元素的信息外，还要存储指向下一个节点的指针，逻辑上相邻的元素在物理空间上不一定相邻,**链表的创建和按值查找效率较低，时间复杂度为O(n),插入和删除效率较高，时间复杂度为O(1)**

### 树形结构：
树形结构是一种非线性的数据结构，其中的元素之间存在一对多的关系，常用的树形结构包括二叉树、AVL树等。**二叉树的时间复杂度会因为具体结构的不同而不同，在最坏的情况下，二叉树可能会变为一个链表，时间复杂度为O(n)，然而如果是平衡的如AVL树，那么插入、删除和查找操作的时间复杂度是O(log n)**

二叉树是一种每个节点最多有两个子树的树形结构，并且子树有左右之分，不能任意颠倒顺序

- 满二叉树：即除了叶子节点以外的所有节点都有两个子树
- 完全二叉树：除了叶子节点以外的所有节点都有两颗子树，并且叶子节点的子树都连续集中在左边

二叉树的遍历方式
- 先序遍历：即先遍历根节点，然后左子树，最后右子树
- 中序遍历：即先遍历左子树，然后根节点，最后右子树
- 后序遍历：即先遍历左子树，然后右子树，最后根节点
- 层次遍历：从上往下，从左往右依次遍历


AVL平衡二叉树：
二叉排序树一定程度上可以提高搜索效率，但是如果二叉排序树本身有序时，此时二叉排序树就会变成一个链表，搜索效率下降。而AVL平衡二叉树由于保持了左右子树的高度差不超过1，可以保证二分查找的搜索效率，因此较为常用

平衡二叉树的调整：
一颗平衡二叉树插入新元素时会出现两种情况，一是未打破平衡，二是打破平衡。
当平衡二叉树的平衡被打破时，需要对树进行调整以保持再度的平衡
- LL左旋：插入节点在失衡节点右子树的右边，进行左旋，左旋后多出来的节点变为左子树的右子树
- RR右旋：插入节点在失衡节点左子树的左边，进行右旋，右旋后多出来的节点变为右子树的左子树
- LR左右旋：插入节点在失衡节点左子树的右边，需要先以左子树为根节点进行一次左旋，然后将根节点进行一次右旋，多出来的节点变为右子树的左子树
- RL右左旋：插入节点在失衡节点右子树的左边，需要先以右子树为根节点进行一次右旋，然后将根节点进行一次左旋，多出来的节点变为左子树的右子树

### 散列结构

散列结构是一种根据关键字直接访问数据的数据结构，也称为哈希表，常见的散列结构包括哈希表和字典，**它们的平均时间复杂度都是O(1)**，这是因为它们都使用了哈希函数来将键值映射到一个可以快速访问的数据结构中（如数组）

**哈希表**：
哈希表的底层原理是将每个键通过哈希函数映射到哈希表（也就是数组）的索引上，然后在这个索引位置上存储与键相对应的值。当需要查找一个键值对时，再通过哈希函数计算出该键对应的索引，并在该索引位置上查找该键值对，从而实现快速查找

哈希函数的作用是将键值映射到一段固定长度的数字串，这个数字串可以看作是该键的指纹，用来唯一的标识这个键。一个好的哈希函数应该能够尽量避免键的碰撞，即不同的键映射到同一个索引的情况，否则会影响哈希表的性能

为了解决碰撞问题，哈希表通常采样开放地址法或链地址法来解决。在开放地址法中，当发生碰撞时，会继续往下一个空闲位置插入，直到找到一个空闲位置；而在链式地址法中，每个索引位置上存储的是一个链表，当发生碰撞时，会将新的键值对添加到链表的末尾


**字典：**
字典是基于哈希表实现的，是泛型版本的哈希表，不存在类型安全问题，并且性能更哈高

## 3.哈希算法的原理

常见的哈希算法有SHA和MD5。
它们的基本原理都是把任意长度的输入转换为一个固定长度的输出。这个映射的规则就是对应的Hash算法，而原始数据映射后的二进制串就是哈希值

一个好的哈希算法需要满足以下要求：
- 从hash值不可以反向推导出原始的数据
- 输入不同的数据会得到不同的哈希值，输入相同的数据会得到相同的值
- 效率要高，能快速地计算出哈希值
- 冲突概率要小，尽可能避免不同的数据具有相同的哈希值，当发生冲突时使用链地址法或开放地址法来解决哈希冲突

## 4.可以通过哪些方式解决哈希冲突

1.链地址法：
将具有相同哈希地址的键存储在同一个链表中。这样，每个索引都对应一个链表，链表中的每个节点都包含一个冲突的键及对应的值。当需要查找一个键时，首先使用哈希函数找到对应的链表，然后在链表中线性搜索该键

优点：
- 方式较为简单，只需要将冲突的元素添加到对应的链表中
- 当哈希表的的负载因子（即元素数量与表大小的比值）较高时，仍能保持良好的性能

缺点：
- 需要额外的内存来存储链表，当存储空间有限或者元素数量非常大时可能会出现一些问题
- 如果链表过长，查找效率会降低，因为需要在链表中进行线性搜索

2.开放地址法：
当哈希函数将一个键映射到已经被占用的索引时，开放地址法会计算下一个索引，直到找到一个未被占用的所用。在这种方法中，所有的键都被直接存储在哈希表里，发生冲突时会寻找下一个空地址，直到找到为止。开放地址法有三种方式来寻找下一个位置，分别是**线性探测、二次探测和双重哈希**
优点：
- 不需要额外的内存来存储数据，所有的数据都直接存储在哈希表中
- 在哈希表的负载因子较低时，查找效率较高

缺点：
- 当哈希表的负载因子较高时，冲突的可能性增加，可能导致查找效率降低
- 需要复杂的冲突解决策略，如线性探测、二次探测和双重哈希等


## 5.开放地址法的三种寻找位置方式

**1.线性探测法：**
即通过哈希计算某个值应该放在某个位置时若这个位置已有值，则去下一个相邻的位置查找是否可以存储，直到找到空闲位置

优点：
- 实现简单，适合数据量较小，冲突少的情况

缺点：
- 容易产生堆积现象，即一旦开始冲突，后续的冲突可能会越来越严重，不适合大规模的数据存储，会浪费很多空间


**2.二次探测法：**
与线性探测法类似，但是查找的步长为冲突次数的平方，可以更快的找到空闲位置

优点：
- 与线性探测法比处理冲突时可以避免聚集险种，冲突的元素会被尽可能均匀的分布再哈希表中，从而使查找时间相对均匀

缺点：
- 实现会稍微复杂，并且如果哈希表的大小不是某种特定的类型，可能无法探测到哈希表的所有位置


**3.二次哈希法：**
把关键字用不同的哈希函数再做一遍哈希，用这个结果作为步长进行查找

优点：
- 有效的避免聚集现象

缺点：
- 实现较为复杂。并且需要存储多个哈希函数，占用内存较大





## 6.简述二分查找

二分查找的前提是已经排好顺序的一列元素（这里假设从小到达）；首先记录中间元素、最大元素和最小元素，然后判断查找元素和中间元素的大小关系，如果查找元素大于中间元素，则更新最小元素下标为中间元素下标+1，然后在新的数列中重复此操作，直到找到该元素。**二分查找的时间复杂度为O(log n)**


## 7.排序算法原理

冒泡：两两对比，顺序错误就调换。**评价和最坏情况下的时间复杂度都是O(n^2)，最好情况下（数组本来就有序）时间复杂度为O(n)**

选择：将第一个元素看为已排序的，然后从未排序序列中选择最小或者最大的，然后放到已排序序列末尾或者开头，然后从剩余未排序选择最小或最大，放到已排序序列末尾或开头。**无论最好、最坏还是平均情况，时间复杂度都是O(n^2)**

插入：将第一个元素看为已排序的，从第二个元素开始与已排序元素比较，找到位置插入，如果当前元素小于已排序的某个元素，就后移然后为当前元素腾出插入位置，重复上面步骤，直到排序完成。**最好情况下的时间复杂度为O(n)，平均和最坏情况下的时间复杂度都是O(n^2)**

希尔：插入的一种优化版本，原理类似，区别就是将整个序列分为多个子序列，然后对每个子序列进行插入，每个子序列排序完后再进行一次插入就完成所有排序。**希尔排序的时间复杂度取决于增量序列的选择，一般情况下，其时间复杂度在O(nlog n)到O(n^2)之间**

快速：要用到递归思想，思路就是选择一个基准元素，然后将排序序列分为两个子序列，其中一个子序列的元素都小于基准元素，另一个序列都大于基准元素，然后对再对每个子序列重复上述排序，直到完成

二分查找：是在已排序序列中查找某个元素，先找出中间位置元素，然后比较中间元素与查找元素，等于说明找到了，查找元素小于中间元素，则以开头为起始，中间元素-1为结尾继续执行，以此类推。**在最优和平均情况下，快排的时间复杂度为O(nlog n),在最坏情况下，时间复杂度会退化到O(n^2)**

[代码](https://github.com/shishouheng/Unity-learning/blob/main/note/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95.md)

## 8.如何选取合适的排序算法

对于排序算法的选择需要根据具体的情况来选取，需要从以下情况进行考虑
- **稳定性：** 确定是否需要稳定的排序，数据在排序前后是否会改变原本的位置，如果不会交换位置，就是稳定的排序算法。
- **数据量：** 对于小规模的数据，可以选择时间复杂度为O(n^2)的算法，如插入排序、选择排序。但对于大规模数据的排序，更高效的算法如快速排序、归并排序更合适
- **数据的乱序程度：** 对于部分有序的数组，可以选择插入排序。而对于无序数组或者完全逆序的数组，可以使用快速排序或归并排序
- **空间复杂度：** 如果内存空间紧张，可以选择原地排序的算法，如快速排序

## 9.如何选取合适的数据结构

数组：**由于数组支持随机访问，因此适用于需要频繁查询，少插入或删除的情况**

链表：**适用于频繁插入和删除操作的场景，不适用于需要进行频繁查询的场景**
 - 如管理游戏事件和消息的处理会需要进行频繁的插入和删除操作。所以可以通过链表将它们连接起来，依次处理每个事件或消息

栈：**通常在需要先进后出操作的场景中使用。**
- 管理场景的切换，进入新场景时把当前场景压栈，然后到另一个新场景时如果要返回到上一个场景就从栈中弹出来；
- 实现撤销功能，比如撤销功能，当用户进行操作时，将操作前的状态压入栈，撤销时直接弹出上一个状态
- UI界面管理：在游戏中有多个界面，如主菜单、设置界面、游戏界面等，可以使用栈来管理这些界面的显示和隐藏顺序

字典：**键值对的形式存储数据**
- 状态机管理，在一个角色控制器中有多个状态需要进行管理，可以使用字典将它们的名称和对应状态进行关联
- 资源管理，可以通过字典将预制体的名称和对应的GameObject进行关联，方便对它们进行访问和加载

二叉树：
- 碰撞检测：当游戏中有多个物体需要进行碰撞检测时，可以用二叉树将它们的位置进行组织，方便对它们进行快速的碰撞检测
- 寻路算法：在游戏的路径规划中，可以使用二叉树来表示地图的结构，方便进行寻路算法的计算和路径的生成
- AI行为树：可以通过使用二叉树将不同的行为节点进行组织，实现AI的行为逻辑

## 10.C#中的List是如何进行扩容的

- 首次向一个新创建的List中添加元素时，它的容量会被设置为4
- 当继续添加元素直到超过当前容量时，List会创建一个新的数组并将容量扩大为原来的两倍
- 将原数组的元素赋值到新数组中，保持元素的顺序不变
- 更新List的内部数组引用，指向新数组
- 释放原数组的内存空间

扩容操作可能会引发内存重新分配和元素复制的开销，因此尽量通过指定初始容量来避免频繁的扩容操作


## 11.C#中的字典如何实现一个键对应多个值

可以通过让一个键对应一个数组或者链表等方式实现


# UI

## 1.UGUI与NGUI的区别

- UGUI的Canvas具有世界坐标和屏幕坐标，而NGUI只有世界坐标，意味着UGUI中的Canvas的位置和大小是相对于屏幕的，即Canvas的位置和大小会根据屏幕分辨率进行自适应调整，而NGUI不会根据屏幕的分辨率进行自适应调整
- UGUI通过Mask实现裁剪（遮罩）效果，而NGUI通过Panel的Clip实现裁剪效果
- NGUI的渲染顺序是通过Widget中的Depth决定的，深度越高越先被渲染，而UGUI的渲染顺序是根据在层级面板的顺序决定的，越靠下越先被渲染
- UGUI不需要绑定碰撞器，只要勾选Racaste target就可以自动拦截事件，而NGUI需要绑定Collider才能拦截事件
- UGUI的锚点是相对于父物体的，而NGUI的锚点相对的目标是可以自行设置的
- NGUI有较强大的动画系统和丰富的脚本，而UGUI需要自行编写脚本实现
- NGUI需要手动创建图集，而UGUI可以自动帮我们打包图集
- NGUI提供了较多的动画组件


## 2.Image和RawImage的区别？

- Image比RawImage更耗费性能
- Image只能使用Sprite属性的图片，但是RawImage什么样的都可以使用
- Image的功能更丰富，可以实现资源的不同的Image Type（simple、sliced、tiled和filled），但同样性能开销也更大
- RawImage可以直接将Texture赋值给它，实现相对简单，在处理大的背景图像时有更好的性能


## 3.Anchors和Pivot的区别

Anchors是当前物体在父物体上的固定点，无论父物体如何变换，固定点位置不变
Pivot是物体自身的中心，旋转缩放操作都是围绕重心进行的
anchoredPosition是物体的pivot相对于anchors的位置


## 4.UGUI中outline和mask组件的原理

**Outline原理：**
- 在顶点着色器中，根据UI元素顶点的位置，为每个顶点生成一个偏移后的顶点位置。这些偏移后的顶点位置就是描边的轮廓线
- 在片元着色器中，根据轮廓线的位置，将轮廓线的颜色与UI元素的颜色进行混合，生成最终的颜色输出

**Mask组件原理：**
- Mask组件原理是将子对象与遮罩对象进行比较，只显示与遮罩对象重叠的部分，从而实现遮罩效果


## 5.UI在不同设备下的适配

UI适配需要解决的是在不同分辨率下UI的相对位置和大小尺寸保持一个能够接受的效果

对于布局适配首先需要在拼UI的时候就设置好锚点，然后借助Unity提供的一些布局组件来对布局进行适配，保证在不同大小的设备上都能呈现出良好的布局效果。也可以在固定像素大小模式下通过代码来获取用户设备的分辨率与当前设计的分辨率进行一个比值，并按照指定的权重值进行缩放（即让用户设备的宽和高分别除以设计分辨率的宽和高，然后让宽的比值乘我们设定的权重值，而高乘1减去这个比值，并将两者相加赋值给Canvas scaler的scaleFactor实现适配）

对于背景适配的话，可以根据项目组制定的最大适配比例（如19.5：9）和最小适配（如4：3）来让美术出一张较大的图（如1624×1000），当设备的分辨率在我们制定的标准内时就进行裁剪，如果超出这个标准就进行等比缩放


## 6.UI框架总结

构建UI框架的话首先需要定义一个UI脚本的基类UIModule，所有的UI脚本都要派生自这个类，并向外提供打开UI界面和隐藏UI界面时的回调方法。

由于UI的类型可能会很多，而且具有不同的功能，还需要一个枚举和一个类来存储UI界面的种类和每个UI界面所具备的信息，一般命名为UIType和UIModuleData，枚举用来定义UI界面的类型，比如说开始界面StartPanel、设置界面SettingPanel、提示框tipPanel等。而UIModule这个类则用来存储UI预制体的名字、打开该界面是否隐藏其他界面的布尔属性、该界面的预制体和type类型等。

然后需要构建UIManager这个UI管理类，通过UIManager管理所有的UI脚本，这个类需要作为一个单例类并向外提供显示UI界面、隐藏UI界面的方法。同时这个类还需要两个容器来存储UI界面的信息，一个数组在初始化的时候用来注册所有的UI界面（后续添加新界面时也需要在该容器中进行注册），一个字典用来存储所有打开过的界面，当调用打开UI界面的方法时，会先去字典中查询该界面是否打开过，如果打开过，则直接调用，如果未打开过，则去数组中查询是否有该界面，如果有该界面，则实例化该界面，并将该UI界面添加到字典中，如果数组中也没有，说明未注册，则需检查初始化时候的数组中是不是忘记添加了。（loading界面较为特殊，因为游戏中所有的loading界面都是同一个，只是打开的时候传入的字符串不同，因此可以单独管理）

在整体的框架搭建完成后，就可以单独的编写每个UI界面的脚本（需要继承UIModule这个基类）并挂载到对应的UI物体上。


## 7.NGUI的渲染机制

NGUI用Panel来管理渲染，一个UIPanel实例表示一个Panel，其中：
- widgets：表示Panel中需要渲染的物体
- drawCalls：表示Panel中的渲染指令
- UIPanel.list：存放所有的Panel

在渲染时会遍历UIPanellist下的所有Panel中的widget，然后根据它们的depth决定它们的渲染顺序，depth值越低越先被渲染，并根据它们的材质和渲染顺序将他们合为不同的批次，最终每个批次调用一次drawcall进行绘制


## 8.NGUI图集打包策略

NGUI图集打包的目的是通过将多个图片合并成一个大的图片来降低DrawCall次数和内存使用

在NGUI中，可以根据以下因素确定哪些图片应该放在一个图集中：
- 使用频率：如果多个图片经常同时出现在屏幕上，将它们放在同一个图集中可以减少图集切换次数，提高渲染效率
- 将在相同场景或界面中使用的图片放在同一个图集中
- 如果一个图片分辨率较大，可以单独用一张图集来管理


## 9.UI优化

- 动态UI和静态UI分离：避免动态UI网格合并带动静态UI的网格跟随合并
- 拆分复杂UI：根据每个UI的逻辑和功能拆分成不同的预制体，避免UI过大导致实例化缓慢
- 预加载：在游戏加载进度条时把资源加载到内存中，需要用的时候直接激活
- 字体拆分：把常用字体拆分处理，生成一个新的字体文件
- 不需要射线检测的时候尽可能关闭Raycast Target，减少不必要的开销
- 滚屏优化：没必要一次加载所有内容，只加载当前屏幕可以显出出来的内容，在运行时动态判断是否有UI元素移出画面并进行回收利用；如果必须在打开时就加载大量的元素，可以使用时间分割策略来优化
- UI显示和关闭的优化：隐藏时移出屏幕或者设置为看不到的层级，显示时移动到默认位置或设置为可以看到的层级

## 10.如何处理UGUI中的异形按钮

1.最简单的方式是通过子对象拼接成异形按钮的方式实现
2.通过图片的像素检测阈值实现，首先需要开启图片读写，然后设置阈值小于0.1时无响应


## 11.如何避免背包或者排行榜数据过多引起的卡顿

可以通过虚拟列表实现。原理就是打开时初始化固定个数的列表，当滚动列表向下滑动时，当第一个列表要移出视野范围之外时，将它移动到最底层，如此循环执行，然后动态修改每个列表的数据即可




# 网络通信

## 1.客户端与服务器交互的方式有哪些

- HTTP通信（应用层）：如www或UnityWebRequest，通过HTTP协议与服务器进行通信。主要用于获取网络资源，如网页、图片等
- Socket套接字（传输层）：使用C#提供的网络库通过TCP或UDP协议与服务器建立套接字连接。可以通过发送和接收字节流来进行双向通信。这种方式适用于实时性要求较高、需要保持长连接的场景


## 2.什么是序列化和反序列化？有什么作用？

序列化是一种将对象的状态信息转换为可以存储或传输形式的过程；反序列化则是将这种形式的信息还原为对象

它们的作用是：
- 跨平台和跨语言使用数据：序列化后的数据可以在不同的平台或语言之间进行交换
- 数据持久化：通过序列化可以将数据永久保存到硬盘或服务器上
- 网络传输：序列化后的数据可以在网络中进行传输

## 3.TCP和UDP在游戏开发中的使用方式和需要注意的地方

TCP和UDP都是网络传输协议，但它们之间也有一些显著的区别：
- TCP是一种面向连接的协议，它需要在发送数据之前先建立连接，并保证数据的可靠性和完整性，而UDP是一种无连接的协议，不需要建立连接，也不保证数据的可靠性和完整性
- 在unity开发中TCP通常用于实现游戏中的聊天系统、排行榜、用户登录等功能。而UDP通常用于实现游戏中的语音连麦、位置同步、视频流传输等功能（这是因为这类功能对实时性要求较高，使用UDP可以减少延迟，即使有数据丢失，丢失的数据包也可以被后续的数据包所替代）
- TCP的连接建立需要时间，会增加网络延迟，因此不适用于需要快速响应的场景，而且TCP协议对于网络质量要求较高，网络不稳定时可能会导致连接断开或数据丢失。而UDP协议不保证数据的可靠性和完整性，因此需要在应用层进行数据校验和重传等处理


## 4.什么是三次握手

三次握手是建立TCP连接的过程，它需要客户端和服务器总共发送3个包以确认连接的建立

- 第一次握手：客户端向服务器发送一个SYN包，并等待服务器确认。发送完毕后，客户端进入SYN_SENT状态，等待服务器确认
- 第二次握手：服务器收到SYN包后，会向客户端发送一个SYN+ACK包确认连接请求。此时服务器进入SYN_RCVD状态
- 第三次握手：客户端收到SYN+ACK包后，会向服务器发送一个ACK包。发送完毕后客户端进入ESTABLISHED状态。服务器收到ACK包后也进入这个状态

完成以上三次握手后，TCP连接就建立成功了，客户端和服务器就可以开始数据传输


## 5.什么是粘包？如何解决？

粘包是指发送方在发送数据时，多个数据包可能被接收方一次性接收，导致数据粘在一起无法正常解析

解决方案：
- 固定包长：发送方在发送数据时将每个数据包固定长度，接收方按照固定长度进行接收和解析。
- 分隔符：发送方在数据包之间插入一个特定的分隔符，接收方根据分隔符进行数据包的切割和解析
- 消息头：发送方在数据包钱添加一个消息头，包含数据包的长度信息，接收方先读取消息头中的长度信息再根据长度读取对应长度的数据包


## 6.网络传输中的同步阻塞和异步非阻塞的区别

同步异步是针对调用者来说的，当调用者发起一个请求后，是否需要等待被调用者的反馈，如果需要等待就是同步，否则就是异步。
阻塞非阻塞是针对被调用者来说的，当被调用者收到一个请求后，做完请求任务才给处反馈就是阻塞，如果收到请求直接给出反馈再去做任务就是非阻塞

因此
- 同步阻塞就是指再需要某些资源时马上发起请求，并暂停本线程之后的程序，直至获得所需的资源
- 异步非阻塞就是指需要某资源时不马上发起请求，而是安排一个以后的时间再发起请求。当到了那时拿出请求时，马上可以得到答复，然后继续执行之后的程序。但如果得到的不是完整的资源，之后周期性的发起请求。再最终获得资源之后，通过回调的方式将结果异步反馈


## 7.帧同步和状态同步原理

帧同步是指客户端把操作上传服务端，服务端不模拟操作，把操作转发给所有客户端，这意味着所有的游戏逻辑都在客户端执行，服务端只负责转发客户端的操作。例如，玩家执行一个攻击操作，对受击者造成了一定的伤害，然后客户端会将一系列的操作上传到服务端并分发给所有的客户端，让所有玩家接收到这个操作的发生

优点：
- 开发效率高，因为战斗逻辑都写在客户端，服务端只负责转发操作消息，双端开发时不需要做额外的对接工作
- 客户端之间的同步相对较快，由于不需要服务端进行模拟计算，客户端之间的同步速度较快，可以减少延迟

缺点：
- 安全性低，所有数据都在客户端，所以解析客户端数据之后，很容易出现作弊
- 对网络延迟的适应性差，如果一个玩家的延迟较高，可能导致所有玩家的体验都不好

状态同步是指客户端把操作上传服务端，服务端根据客户端上传的操作来计算游戏状态的变换，然后把模拟的结果转发给所有客户端。这意味着在状态同步中，游戏逻辑主要在服务端执行，客户端负责显示游戏状态和接收用户输入。例如，玩家执行一个攻击动作，服务端会根据这个攻击操作来计算被攻击者的血量减少多少，然后将这个结果发送给所有客户端

优点：
- 安全性高，因为状态同步的所有逻辑都是在服务端计算的，数据就难以被获取，作弊成本的增加
- 服务端进行模拟操作可以保证所有客户端的游戏状态保持一致

缺点：
- 开发效率较低，服务端负担较大
- 由于服务端需要进行模拟计算并发送结果，可能会导致网络延迟


综上所述，对于实时性很强同时需要较高的安全性，那可以使用状态同步，否则使用帧同步


## 8.网络游戏开发中，网络传输数据的基本流程是什么

- 建立连接：客户端与服务器之间建立网络连接，通常通过TCP或UDP协议完成
- 发送请求：客户端通过网络连接向服务器发送请求。这个请求可能包含玩家的操作、游戏状态等信息
- 处理请求：服务器接收到客户端的请求后，会进行相应的处理。包括更新游戏状态、处理玩家操作等
- 返回响应：服务器处理完客户端的请求后，会向客户端返回一个响应。这个响应就是服务器处理请求后的结果
- 接收响应：客户端接收到服务器的响应后，会根据响应的内容更新游戏界面、显示操作结果等
- 关闭连接：当游戏结束或者玩家退出游戏时，客户端和服务器会关闭之前建立的网络连接

## 9.游戏开发中，客户端与服务端的数据交互经常采用什么方式

对于消息数据通常采用Socket或HTTP；这是因为socket提供了长连接的通信方式，可以实现实时的数据交互。
对于文件数据通常使用HTTP；虽然文件数据也可以使用Socket，但是对于文件传输HTTP更加高效，因为HTTP提供了许多用于文件传输的特性，如数据压缩、缓存、断点续传等


# 设计模式

## 1.设计模式

- 单例模式：单例模式用于确保一个类只有一个实例，并提供全局访问点。在unity开发中单例模式常用于管理全局的资源。如：UIManager、GameManager、ConfigDataManager、AudioManager等
- 管理者模式：通常用于管理和协调游戏中的各个模块和系统，管理者模式将各个模块解耦，使得它们可以独立工作并提供统一的接口供其他模块使用
- 状态模式：用于管理游戏中的状态和状态之间的切换。比如游戏中角色的各种状态的切换就可以通过状态模式进行管理
- 工厂模式：用于创建对象并隐藏创建对象的细节，同时向外部提供统一的接口。工厂模式常用于创建游戏中的角色或其他复杂对象，将对象的创建过程封装，使得代码结构清晰并减少代码耦合
- 观察者模式：用于实现对象之间一对多的依赖关系。当某个事件发生时，所有注册的观察者会收到通知并执行相应的操作。如UGUI中的事件系统就是基于观察者模式实现的

## 2.MVC和MVVM的区别

- MVC：在MVC模式中分为数据层、视图层和逻辑层。其中Model层和View层会有耦合
- MVVM：是对MVC的改进，抽离了视图、数据和逻辑，并限定了Model和View只能通过ViewModel进行通信


# Shader

## 1.CGPROGRAM是什么

CGPROGRAM是unity中编写shader的语法结构，用于定义一段shader程序，其中可以包含顶点着色器和片元着色器的代码，在一段CGPROGRAM块中通常包含以下几个部分：properties属性、subshader渲染通道和pass渲染过程

## 2.Shader分类和功能

- Fixed function shader：固定函数着色器，功能固定，只公开一些常用的参数可调整，功能有限。
- Surface Shader ：表面着色器，使用unity预制的光照模型进行光照运算，开发者只需要考虑物体表面的外观和材质属性
- Vertex and Fragment Shader：顶点/片元着色器，是灵活性最高的一种着色器。开发者可以自己控制顶点的位置和属性以及像素的颜色和属性



## 3.卡通着色的实现方式

卡通着色的特点是强调物体的边缘和阶梯化的色阶，因此主要通过这两个方面进行实现

首先就是通过描边算法来检测物体的边缘，并对检测到的边缘进行加粗或者上色，然后使用阶梯化的颜色来代替光照计算的结果。

## 4.shader中v2f结构体和appdata结构体的作用是什么

- appdata:  这个结构体主要存储模型的信息，常用于顶点着色器中，表示cpu传递到gpu的顶点数据，包含模型的顶点坐标、法线方向、切线方向、纹理坐标等，这些数据都是由unity自动填充的
- v2f：这个结构体用于片元着色器中，表示从顶点着色器传递到片元着色器的数据，包含顶点着色器计算得到的数据，如顶点位置、法线、纹理坐标等，以及其他需要在片元着色器中使用的数据，如描边信息、光照强度等



## 5.shader中的常用API

- **Tex2D:** 用于在shader中读取纹理颜色的函数。需要一个纹理采样器和一个uv坐标作为输入，并返回该坐标处的纹理颜色
- **UnityObjectToClipPos:** 用于将对象的空间坐标转换为裁剪空间坐标的函数。需要一个空间对象坐标作为输出，并返回该坐标在裁剪空间中的位置
- **UnityObjectToWorldNormal:** 用于将对象空间法线转换为世界空间法线的函数。需要一个对象空间法线作为输入，并返回该法线在世界空间中的方向
- **UnityWorldSpaceViewDir:** 用于获取相机视角方向的函数。需要一个世界空间坐标作为输入，并返回从该坐标到相机的视角方向
- **Clip：** 是要给用于将裁剪空间坐标进行裁剪的函数。需要一个裁剪空间坐标作为输入，并返回是否需要进行裁剪的布尔值
- **saturate:** 这是一个用于将值限制在0到1之间的函数。需要一个值作为输入，并返回该值在0到1之间的限制值
- **pow:** 用于计算幂函数的方法。需要一个底数和一个指数作为输入，并返回底数的指数次幂的值
- **smoothstep：** 用于计算平滑阶段函数的方法。需要一个起始点、结束点和一个插值作为输入，并返回在起始点和结束点之间的平滑插值





## 6.渲染队列

unity中的渲染队列是一种用于管理渲染顺序的机制。渲染队列是一个数字，用于指定渲染顺序，数字越小的对象越先被渲染，默认的渲染队列顺序是Opaque(不透明)、Transparent（透明）、Overlay（覆盖）


## 7.点乘叉乘

点乘是两个向量之间的一种运算，如向量a和向量b的点乘结果为：|a||b|cosθ，即它们的模长乘它们之间夹角的余弦值。
**点乘的结果表示了两个向量在方向上的相似程度**，如果ab向量方向相同，点乘结果为1，方向相反，点乘结果为-1；相互垂直，点乘结果为0.
在游戏开发中，通过点乘可以实现以下功能
- 判断敌人与玩家的前后关系
- 将向量的长度进行归一化就可以求出两个向量之间的角度
- 在shader中通过计算光线向量和物体法线向量的点乘结果来得到光照效果

叉乘也是两个向量之间的一种运算，**两个向量的叉乘结果是一个垂直于原本两个向量所在平面的向量**
在游戏开发中，通过叉乘可以实现以下功能：
- 可以用来判断目标物体在自身的顺时针方向还是逆时针方向，叉乘结果大于0说明敌人在自身顺时针方向，叉乘结果小于0说明敌人在自身的逆时针方向
- 计算平面法向量
- 判断三角面片的朝向



## 8.渲染流水线

unity的渲染流水线是指图形渲染的处理流程和步骤，描述了从场景中的模型、材质、和光照等数据到最终呈现在屏幕上的图像的过程，主要分为以下几个阶段

- 1.应用阶段：由cpu负责，这一阶段主要由开发者准备好摄像机、模型和光源等数据，并做好相应的剔除工作，并设置好材质、纹理、shader等渲染状态，最后输出渲染所需要的图元
- 2.几何阶段：由gpu负责，把上一阶段传递来的图元进行逐顶点，逐多边形的操作，并把顶点坐标从模型空间经过一系列转换最终到屏幕空间。同时输出屏幕空间的二维顶点坐标、顶点深度、顶点颜色等数据，然后交给光栅器处理
- 3.光栅化阶段：由gpu负责，对上个阶段的逐顶点数据进行插值，再做逐像素处理，决定哪些像素会被绘制，哪些会被剔除，并计算它们的颜色和光照

在每个阶段又会进行许多不同的操作，如：

几何阶段：
- 顶点着色器：处理单个顶点数据，开发者需要在顶点着色器里完成坐标系转换，把顶点从模型空间转换到裁剪空间，最终得到归一化坐标，还会进行逐顶点光照，并准备好后续阶段需要的其他数据，比如纹理坐标、顶点颜色等
- 曲面细分着色器：细分图元
- 几何着色器：执行图元的着色操作，产生更多图元
- 裁剪：之前阶段所得到的是NDC立方体空间，在OpenGL中这个空间大小是（-1，-1，-1）到（1，1，1）；在DirectX中这个空间大小是（0，0，0）到
（1，1，1），完全在空间内的会保留，完全在空间外的会被抛弃，一半在空间内一半在空间外的会将空间外的裁剪，最终得到的是我们视野能看到的部分
- 屏幕映射：即将三维转换为二维，经过裁剪后的NDC坐标，依然是三维坐标，屏幕映射的任务就是把每个图元的x，y坐标转换到屏幕坐标系，通过缩放确定图元的屏幕坐标位置。然后由屏幕坐标和z坐标构成窗口坐标系。（OpenGL会以屏幕左下角为最小坐标，DirectX会以左上角为最小坐标）

光栅化阶段：
- 三角形设置：构建三角形网格数据，通过上个阶段输出的三角形顶点信息，计算出三角形的边界从而构建三角形网格数据
- 三角形遍历：检测每个像素被哪个三角形所覆盖，从而生成片元，三角的三个顶点会对覆盖的每个像素的数据进行插值，比如深度、坐标、颜色
- 片元着色器：在三角形遍历后生成的片元的所有数据在这个阶段会通过算法利用数据生成或计算片元的颜色，然后通过纹理采样或逐像素光照等渲染技术输出片元的颜色，这个阶段也会进行透明度测试
- 逐片元操作：经过模板测试和深度测试后决定好了每个片元的可见性，测试通过的片元要和已存在颜色缓冲区的颜色进行合并，开启混合的就进行混合，未开启混合的则覆盖
- 屏幕图像：经过以上计算，内容就会在屏幕上了，GPU采用多重缓冲机制，渲染发生在后置缓冲，渲染结束后会切换到前置缓冲来显示


## 9.四大测试是哪些？它们的作用是什么？

四大测试分别是裁剪测试、透明度测试、模板测试和深度测试（按执行顺序排序），它们的作用都是剔除不可见的像素。它们在渲染管线的不同阶段进行测试：
- 裁剪测试：用于确定哪些像素可见，将裁剪区域内的像素保留，而裁剪区域外的像素丢弃
- 透明度测试：通过与预设的透明度阈值进行比较，将透明度满足条件的像素保留，而透明度不满足条件的像素丢弃。可以用于实现透明物体的渲染效果
- 模板测试：根据模板缓冲区的值来决定像素是否被绘制或修改，可以实现一些特殊的渲染效果，如镂空效果、轮廓效果等
- 深度测试：用于比较像素的深度值与深度缓冲区对应位置的深度值。如果像素深度值小于模板缓冲区深度值，则该像素被绘制，否则被丢弃。深度测试可以实现正确的遮挡关系

## 10.渲染优化

- 光照贴图：对于游戏中固定不动的物体若还进行实时光照就会浪费很多性能，因此可以将它的光照效果和阴影通过光照贴图的形式进行缓存
- 遮挡剔除：对于游戏中固定不动的物体，如果存在遮挡情况就无需绘制整个物体，而是选择性的绘制未被遮挡的部分，通过遮挡剔除技术可以对模型进行分割成许多小块，被遮挡的部分会被剔除不发送给GPU渲染
- LOD：多层次细节，即基于模型的重要程度或视角的远近绘制不同精度的模型，当距离超过一定限度，甚至对模型进行剔除
- MipMap：多级贴图，由一系列不同大小的纹理图像组成，每一个图像都是前一个图像的一半大小。当启用MipMap时，unity会自动根据物体与相机的距离选择合适的纹理级别，从而减少GPU的工作量

## 11.Shader是什么，用什么用

shader是一种用于定义渲染对象的程序。描述了对象的外观、材质和光照效果。在渲染场景时，每个对象都会使用对应的shader来生成像素颜色，并最终呈现到屏幕上。unity种可以使用shaderlab和hlsl编写自定义的shader


## 12.是不是所有矩阵都有逆矩阵？如何计算一个矩阵的逆矩阵

不是所有矩阵都有逆矩阵。
计算流程：
- 确定矩阵是否为方阵（即行列数是否相等）
- 计算矩阵的行列式，若行列式为0，则该矩阵没有逆矩阵
- 计算矩阵的代数余子式矩阵
- 计算标准伴随矩阵（转置代数余子式矩阵）
- 计算逆矩阵（标准伴随矩阵/行列式）

## 13.齐次坐标是什么？有什么用？

齐次坐标就是将一个原本是n维的向量或矩阵用n+1维表示，是一种扩展的坐标系统，用于在计算机图形学种进行数学运算。

利用齐次坐标，我们可以区分向量和点，能够表示出平移变换


## 14.顶点着色器和片元着色器有什么作用

顶点着色器：
	主要作用是对物体的顶点位置进行变换和投影，从本地坐标系转换到世界坐标系和相机坐标系等。在这个阶段，顶点着色器还可以计算光照的影响、法线的变换以及传递一些数据供后续阶段使用

片元着色器：
	主要处理像素的颜色、纹理和光照。在顶点着色器之后进行，渲染管线会对物体进行光栅化，将物体的几何形状转换为像素。在片元着色器中，针对每个像素会进行插值和纹理采样，以及计算光照、阴影、反射等效果。片元着色器最终输出的颜色将决定每个像素的显示效果


这连个着色器阶段协同工作，将3D场景中的几何信息转换为2D屏幕上的像素颜色，从而实现图像的渲染和显示


## 15.普通项目、URP项目和HDRP项目的区别是什么

渲染管线不同。
普通项目：
	使用Unity默认的渲染管线，适用于简单的游戏，不支持一些高级渲染特性，但适用于广泛的平台和设备

URP项目：
	也是官方提供的渲染管线，在性能和质量之间取得平衡，提供了一些轻量级的效果和优化，可以在保持性能的同时实现较好的视觉效果

HDRP项目：
	官方提供的高级渲染管线，可以提供逼真的图形质量和高度可定制的渲染效果


## 16.OpenGL和DX的最大区别是什么

它们都是计算机图形API。它们之间最大的区别是OpenGL是一个跨平台、跨语言的开放图形库，可以支持各种平台，而DX是微软创建的，只针对微软相关平台

# 项目问题

## 1.Unity如何调试排查Android上运行的项目问题

**1.断点调试：**
- 通过数据线链接运行项目的Android设备
- 发布时开启开发模式构建、自动连接分析器、脚本调试和等待托管调试器，然后Build and Run即可
- 最后通过性能分析器排查性能问题，并且还可以进行断点调试

**2.获取打印调试信息：**
- 2019.4以上版本可以使用Android Logcat工具获取信息
- 2019.4以下版本可以使用ADB（安卓调试桥）工具

**3.获取设备输入信息：**
- 可以利用Unity Remote来测试移动设备的输入相关逻辑


## 2.如何在Unity中实现多语言支持？

1.单包：
- 将所有涉及多语言的图片、文本通过配置表去配置，当显示这些内容时，根据配置表中的信息去动态加载，所有地区通用一个安装包，只是游戏中进行地区判断或语言选择

2.分包：
- 根据不同地区发布不同的安装包


## 3.Unity双端如何进行通信

实现双端通信需要以下几个步骤

- 首先需要建立一个网络连接，通过这个网络连接与服务端进行数据的交互
- 然后需要定义该网络连接的通信协议，如socket，客户端安装协议将数据编译成二进制流并发送请求，服务端收到请求，解析协议，然后按照协议号进行响应并返回客户端相应的数据
- 还需要进行消息处理，如消息内容的序列化和反序列化，并最终对数据进行相应的处理



