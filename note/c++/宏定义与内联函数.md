宏定义和内联函数都是为了减少函数调用开销和提高代码运行效率而引入的机制，但它们的实现方式和作用机制有所不同

## 宏定义

\#define在c++中是预处理指令的一种，一般用于定义宏，主要有两种用途

- 定义常量
- 创建宏函数

无论哪种作用其都是在编译时替换文本

例：
```cpp
#include <iostream>

#define PI 3.14159
#define SQUARE(x) ((x) * (x))

int main() {
	//编译时替换为std::cout << "PI: " << 3.14159 << std::endl;
    std::cout << "PI: " << PI << std::endl;
    //编译时替换为std::cout << "Square of 5: " << ((5)*(5)) << std::endl;
    std::cout << "Square of 5: " << SQUARE(5) << std::endl;
    return 0;
}

```

优点：
1.简单：用于定义常量和简单的代码替换
2.高效：直接文本替换，没有函数调用的开销
缺点：
1.没有类型检查：宏展开是纯文本替换，可能导致难以发现的错误
2.调试困难：宏展开后代码的可读性差，难以调试
3.作用域问题：宏没有作用域控制，可能导致命名冲突


## 内联函数

内联函数使用inline关键字定义。提示编译器将函数调用展开为函数体代码，从而避免函数调用的开销。
内联函数的定义和普通函数类似，只需在函数声明前加上inline关键字即可。但是编译器并不一定会讲所有声明为内联函数的函数都进行内联，是否内联取决于编译器的实现和优化策略

```cpp
#include <iostream>

inline double square(double x) {
    return x * x;
}

int main() {
    std::cout << "Square of 5: " << square(5) << std::endl;
    return 0;
}

```

优点：
- 类型安全：内联函数遵循C++的类型检查和函数语法规则
- 调试友好：内联函数可以使用调试工具进行调试
- 作用域控制：内联函数具有函数作用域，避免命名冲突

缺点：
- 编译器优化：内联只是一个建议，编译器可以选择不内联函数
- 代码膨胀：大量使用内联函数可能导致代码膨胀，增加编译时间和可执行文件的大小
- 复杂性限制：过于复杂的函数或递归函数不能被内联