
在c++中，explicit通常用于构造函数的声明，用于防止隐式转换。当将一个参数传递给构造函数时，如果构造函数声明中使用了explicit关键字，则只能使用显示转换进行而不能使用隐式转换。这个关键字可以防止编译器执行预期外的类型转换，提高代码的安全性

## 1.构造函数的类型转换作用

在理解explicit关键字之前，需要了解构造函数的类型转换作用，以便与更好的理解explicit关键字，例如一个日期类

```cpp
class Date
{
public:
// 构造函数
	Date(int year)
		:_year(year)    // 初始化列表
	{}
 
private:
	int _year;
	int _month = 3;
	int _day = 31;
};
```

对于下面的d1很明显会调用了有参构造进行初始化，不过对于d2来说，也是一种构造方式
```cpp
int main()
{
    // d1 和 d2 都会调用构造函数
	Date d1(2022);   
 
	Date d2 = 2023;
	
	return 0;
}
```

虽然`Date d2 = 2023;` 看起来像是赋值，但实际上它是通过隐式转换和直接初始化来创建对象的，可以对比以下操作
```cpp
int i = 1;
double d = i;
```

对于类型转换而言，其实并不是直接将等号右边的值赋给左边的对象，而是会在中间产生一个临时变量，例如右边的i会先去构造一个double类型的临时变量，并把这个临时变量里的值初始化为1，然后再通过这个临时对象进行拷贝构造给d，这就是编译器底层进行的处理

同样对于我们自己声明的日期类，由于他的构造函数会接受一个int类型的参数，所以当编译器执行到`Date d2 = 2023;`代码时，并发觉Date类有一个接受int参数的构造函数，编译器会调用Date类的构造函数，并传入2023作为参数来构造一个临时的Date对象，然后这个临时的Date对象会被用来初始化d2，因此`Date d2 = 2023;`是合法的，因为编译器对其进行了隐式转换


## 2.explicit关键字的作用

但是当出现某种情况我需要避免出现隐式类型转换该怎么解决呢，这时就可以使用explicit关键字，用它来修饰构造函数就可以禁止隐式类型转换

```cpp
class Date {
public:
    explicit Date(int year) : _year(year) {}
private:
    int _year;
};

int main() {
    Date d1(2022); // 仅允许显式调用
    // Date d2 = 2022; // 错误：不允许隐式转换
}
```

## 3.哪些情况需要使用explicit关键字

假设我有一个类MyInt，表示一个整数，并且有一个构造函数可以将int类型的参数转换为MyInt类型：
```cpp
class MyInt {
public:
    MyInt(int n) : num(n) {}
private:
    int num;
};
```
我们可以用如下方式来创建一个MyInt对象
```cpp
MyInt a=10；//通过隐式构造的方式来调用构造函数创建临时变量并赋值给a
```

但在一些情况下，这种隐式转换可能会导致问题，比如如下这个函数

```cpp
void f(MyInt n){
	//do something
}
```
如果我们调用这个函数并传递一个int类型的值作为参数
```cpp
f(10);
```
虽然这样也能编译通过，但有些情况下我们并不希望f函数可以接收一个int类型的参数，这是预期外的，可能会导致错误结果，这时我们就可以将MyInt的构造函数声明为explicit，这样如果还通过
```cpp
f(10);//编译错误，不能使用隐式转换
```
这种方式去调用该函数，就会导致编译报错

