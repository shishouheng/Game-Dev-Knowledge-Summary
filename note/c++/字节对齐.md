在c++中，字节对齐是内存分配的一种策略。当分配内存时，编译器会自动调整数据结构的内存布局，使得数据成员的起始地址与其自然对齐边界相匹配

## 为什么需要字节对齐

- 硬件要求：许多处理器要求特定的数据类型对齐到特定的字节边界，以便更高效的读区和写入数据
- 内存访问效率：对齐数据可以减少处理器访问内存时的额外操作，从而提高性能
- 硬件兼容：确保程序在不同的硬件平台上都能正确运行

理论上，任何类型的变量都可以从任意地址开始存放，然而实际上访问特定类型的变量通常需要从特定对齐的内存地址开始。**因为如果不对数据存储进行适当的对齐，可能会导致存取效率低下**。

所以，各种数据类型需要按照一定的规则在内存中排列，而不是顺序的一个接一个牌坊，这种排列就是字节对齐

例如，有些平台每次读区都是从偶数地址开始，如果一个int类型（假设是32位系统）存储在偶数地址开始的位置，那么一个周期就可以读区这32位，但如果它存储在奇数地址开始的位置，则需要读两个周期，并将两次读区的结果的高低字节拼凑才能得到这32位数据。这样很明显会降低读取效率

总结：**字节对齐有助于提高内存访问速度，因为许多处理器都优化了对齐数据的访问。但是，这可能会导致内存中的一些空间浪费**


例：
```cpp
#include <iostream>

class Example {
    char c;
    int i;
    double d;
};

int main() {
    std::cout << "Size of Example class: " << sizeof(Example) << " bytes" << std::endl;
    return 0;
}

```

在这个示例中，类 `Example` 包含一个 `char` 类型的变量 `c`，一个 `int` 类型的变量 `i`，以及一个 `double` 类型的变量 `d`。在64位系统上，编译器会对这些成员进行对齐。

在64位系统上，内存布局可能如下：
- char c占用1个字节
- int i需要对齐到4字节边界，因此需要3个字节的填充
- double d需要对齐到8字节边界

内存布局如下
```arduino
| char c | 填充 | int i | double d |
```

因此总大小是1 + 3 + 4 + 8 = 16 个字节


