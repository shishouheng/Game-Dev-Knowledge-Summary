# 一、UGUI与NGUI的区别

- UGUI的Canvas具有世界坐标和屏幕坐标，而NGUI只有世界坐标，意味着UGUI中的Canvas的位置和大小是相对于屏幕的，即Canvas的位置和大小会根据屏幕分辨率进行自适应调整，而NGUI不会根据屏幕的分辨率进行自适应调整

- UGUI通过Mask实现裁剪（遮罩）效果，而NGUI通过Panel的Clip实现裁剪效果

- NGUI的渲染顺序是通过Widget中的Depth决定的，而UGUI的渲染顺序是根据在层级面板的顺序决定的，越靠下越先被渲染

- UGUI不需要绑定碰撞器，只要勾选Racaste target就可以自动拦截事件，而NGUI需要绑定Collider才能拦截事件

- UGUI的锚点是相对于父物体的，而NGUI的锚点相对的目标是可以自行设置的

- NGUI有较强大的动画系统和丰富的脚本，而UGUI需要自行编写脚本实现



# 二、批处理

## 2.1  批处理的概念：

在unity中一个普通的3D模型渲染出来的过程是：

- CPU将这个模型需要的网格、贴图、材质以及Shader加载到内存中

- CPU设置渲染状态，即设置好渲染某个网格需要对应的贴图、材质、Shader等

- CPU向GPU发送渲染指令，然后GPU按照CPU提前设置好的渲染状态在对应的网格上渲染相应的贴图、材质和Shader，同时将渲染好的模型显示到屏幕上

每一次CPU发送渲染指令，GPU完成渲染指令的过程就是一次DrawCall。

按照这个逻辑如果场景中存在100个模型，那就会存在100次DrawCall，但是通过Stats面板的数值可以观测到Bathces（可以理解为DrawCall次数）明显会小于场景中的模型数量，这就是因为Unity进行了批处理

**批处理就是将相同材质、相同贴图、相同Shader的模型的网格合并在一起组成一个大网格，然后调用一次DrawCall，直接渲染这一个大网格**

## 

## 2.2   批处理的意义：

批处理的意义就是为了减少DrawCall次数，因为CPU调用Drawcall之前需要准备数据、设置渲染状态，这些都及其耗时，如果Drawcall过多，就会大量进行这两个步骤，从而影响性能



## 2.3  UGUI合批

UGUI的渲染和3D模型的渲染过程是一致的，UGUI控件的本质也是网格，因此也可以进行批处理操作，在UGUI中的批处理称为合批，即把某个Canvas下满足合批规则的UI控件的网格合并为一个更大的网格，然后将这些网格合并在一起调用一次Drawcall





# 三、  UI优化

## 3.1  动静分离

即将静态UI元素与动态UI元素分开进行渲染处理，这是因为Unity会自动对UI元素的网格进行合并，将相同材质和纹理的UI元素合并为一个大的网格对象。

如果不将静态UI与动态UI分离，那么每次动态UI的移动导致的网格合并都会导致静态UI的网格跟着合并，造成不必要的性能开销。

将其分开到不同的Canvas渲染后就可以避免动态UI的网格合并影响到静态UI的网格



## 3.2  拆分复杂UI

随着UI的功能增多，逻辑越来越复杂，如果将需要的界面展示，不需要的界面隐藏，会导致UI过大，实例化缓慢，因此就需要根据每个UI的逻辑和功能拆分成不同的对象（prefab），例如有些界面在打开的时候默认是隐藏状态，在某个逻辑触发后才会显示，就应该将其拆分  





## 3.3  UI预加载

即将UI的加载过程放在游戏开始前的加载过程中

即在游戏开始之前使用Resources.Load,但是不实例化，先把资源加载到内存中，然后再第一步的基础上，把UI的实例化和初始化工作也前置，把UI界面隐藏，需要显示的时候再激活



## 3.4  UI字体拆分

把常用字体拆分出来，生成一个新的字体文件



## 3.5  ScrollView滚屏优化

  如背包道具有很多时没必要一次性加载所有的道具，只加载当前屏幕上可以显示出来的固定数量的道具，当识别到玩家滑动时，动态判断是否有UI元素被移出画面，移除画面的元素进行回收利用；如果必须在开始时加载大量的元素，可以使用协程延迟一帧的方式来控制



## 3.6  UI的显示和关闭的优化

- 利用碎片化时间进行预加载，让显示速度变得更快

- 在关闭时隐藏，打开时重新激活

- 隐藏时移出屏幕，显示时移动到默认位置

- 打开关闭时通过调整UI界面的深度或者层级使其排除在相机照射范围之内
