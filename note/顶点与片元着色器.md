# 一、顶点片元着色器与表面着色器的区别

表面着色器是Unity特有的一种着色器代码类型，本质也是顶点片元着色器，使用类似表面材质的描述方式来定义光照、反射、透明度等属性。表面着色器封装了常用的光照模型和材质属性，使得开发更为简单，但缺点是灵活性低，无法控制渲染的细节

而顶点片元着色器更为复杂，但是灵活性很高，需要手动编写渲染的各个阶段，包括顶点处理和片元处理。在顶点处理阶段可以改变顶点的位置、颜色、法线等属性。而在片元处理阶段，可以处理像素级的操作，如纹理采样、光照计算、阴影等


# 二、顶点片元着色器写法

## 2.1 默认内容注释

首先是默认创建的Ulit Shader里的内容
```C#
Shader "Unlit/10.25" //定义一个名为"Unlit/10.25"的Shader
{
	Properties //定义Shader的属性
	{
		_MainTex ("Texture", 2D) = "white" {} //定义一个2D纹理属性，名为"_MainTex"，显示名称为"Texture"，默认值为白色
	}
	SubShader //定义子着色器
	{
		Tags { "RenderType"="Opaque" } //设置渲染类型为不透明
		LOD 100 //设置细节等级为100

		Pass //定义一个渲染通道
		{
			CGPROGRAM //开始编写CG程序
			#pragma vertex vert //指定顶点着色器函数为vert
			#pragma fragment frag //指定片元着色器函数为frag
			#pragma multi_compile_fog //启用雾效果
			
			#include "UnityCG.cginc" //包含Unity的CG库

			struct appdata //定义顶点数据结构体
			{
				float4 vertex : POSITION; //顶点位置
				float2 uv : TEXCOORD0; //纹理坐标
			};

			struct v2f //定义顶点到片元的数据结构体
			{
				float2 uv : TEXCOORD0; //纹理坐标
				UNITY_FOG_COORDS(1) //雾效果坐标
				float4 vertex : SV_POSITION; //裁剪空间中的顶点位置
			};

			sampler2D _MainTex; //纹理采样器
			float4 _MainTex_ST; //纹理变换参数
			
			v2f vert (appdata v) //appdata_base 来自于UnityCG.cginc

			{
				v2f o;
				o.vertex = UnityObjectToClipPos(v.vertex); //将顶点位置从对象空间转换到裁剪空间
				o.uv = TRANSFORM_TEX(v.uv, _MainTex); //进行纹理坐标变换
				UNITY_TRANSFER_FOG(o,o.vertex); //传递雾效果数据
				return o;
			}
			
			fixed4 frag (v2f i) : SV_Target //片元着色器函数
			{
				fixed4 col = tex2D(_MainTex, i.uv); //采样纹理得到颜色值
				UNITY_APPLY_FOG(i.fogCoord, col); //应用雾效果
				return col;
			}
			ENDCG //结束CG程序编写
		}
	}
	FallBack "Diffuse" //如果当前硬件不支持该Shader，则使用内置的Diffuse Shader作为备选方案。
}

```

## 2.2 Tag标签
代码中的Tags是用于告知引擎何时以及用什么方式进行渲染的键值对参数，以下是常用的一些Tags
- Queue:指定渲染顺序，数值小的先渲染。预设的几个值包括
	-  Background(1000):最先调用，通常用于背景方面的渲染
	-  Geometry(2000):默认值，大多数物体用此方式渲染
	-  AlphaTest(2450):进行Alpha测试的几何体使用此队列
	- Transparent(3000):此渲染队列在Geometry和Alpha Test之后渲染，按照从后到前的顺序
	- Overlay(4000):此渲染队列是为了获得覆盖效果
- RenderType：用于将shader分组，以便选择合适的shader，预设的几个值包括
	- Opaque：默认值，表示不透明的物体，这些物体在渲染时不需要考虑深度排序或者混合等问题
	- Transparent：用于有透明效果的物体，这些物体渲染时需要考虑深度排序，以确保透明效果的正确
	- TransparentCutout：用于需要剔除像素而不是混合来实现透明效果的物体
	- Background：用于渲染背景
	- Overlay：用于渲染需要覆盖在所有物体之上的物体，如UI元素
- DisableBatching:使用绘制调用批处理时，一些着色器不起作用，这是因为批处理会将所有几何体转换为世界空间，所以对象空间会丢失，这时就可以使用DisableBatching标签来指示这种情况
- ForceNoShadowCasting：如果添加此标签并且值为true，则使用该子着色器渲染的对象不会投射阴影
- IgnoreProjector：如果添加此标签并且值为true，则使用此着色器的对象不会受到Projector（投影器组件）的影响
- PreviewType：指示材质检视面板预览如何显示材质。默认情况，材质显示为球体，但也可以将PreviewType设置为Plane或者Skybox
- CanUseSpriteAtlas：如果着色器用于精灵图，将此标签设置为false，这样在精灵打包到图集内时，此标签将不起作用


## 2.3 UnityCG定义的AppData结构体

```c#
struct appdata_base 
{
 float4 vertex : POSITION;//顶点坐标
 float3 normal : NORMAL;//顶点法线
 float4 texcoord : TEXCOORD0;//顶点UV
 UNITY_VERTEX_INPUT_INSTANCE_ID
};
struct appdata_tan 
{
 float4 vertex : POSITION;//顶点坐标
 float4 tangent : TANGENT;//顶点切线
 float3 normal : NORMAL;//顶点法线
 float4 texcoord : TEXCOORD0;//顶点UV
 UNITY_VERTEX_INPUT_INSTANCE_ID
};
struct appdata_full 
{
 float4 vertex : POSITION;//顶点坐标
 float4 tangent : TANGENT;//顶点切线
 float3 normal : NORMAL;//顶点法线
 float4 texcoord : TEXCOORD0;//顶点第一纹理坐标
 float4 texcoord1 : TEXCOORD1;//顶点第二纹理坐标
 float4 texcoord2 : TEXCOORD2;//顶点第三纹理坐标
 float4 texcoord3 : TEXCOORD3;//顶点第四纹理坐标
 fixed4 color : COLOR;//顶点颜色
 UNITY_VERTEX_INPUT_INSTANCE_ID
};
```
- appdata_base:是最基本的结构体，包含了位置（POSITION)、法线(NORMAL)和纹理坐标(TEXCOORD0)
- apptada_tan:这个结构体在appdata_base的基础上增加了切线(TANGENT)，通常用于需要进行法线贴图的Shader
- appdata_full:这个结构体包含了位置、法线、切线、顶点颜色（COLOR)以及两个纹理坐标。这是最完整的结构体，通常用于需要进行多种计算和操作的Shader
- appdata_img:这个结构体只包含位置和一个纹理坐标，通常用于只需要进行基本纹理映射的Shader

# 三、案例

## 3.1 将法线信息映射到颜色上

```c#
Shader "Unlit/10.25"
{
	Properties
	{
		
	}
	SubShader
	{
		Tags { "RenderType"="Opaque" }
		LOD 100

		Pass
		{
			CGPROGRAM
			#pragma vertex vert
			#pragma fragment frag
			#pragma multi_compile_fog
			
			#include "UnityCG.cginc"


			struct v2f
			{
				float4 vertex:SV_POSITION;
				float4 col:COLOR;
				float3 n:TEXCOORD0;
				float3 n2:TEXCOORD1;
			};

			
			v2f vert (appdata_base v)
			{
				v2f o;
				o.vertex = UnityObjectToClipPos(v.vertex);
				//将法线信息（从-1到1的向量）映射到颜色上（从0到1的向量）
				o.col.rgb = v.normal*0.5+0.5;
				o.n=fixed3(1,0,0);
				return o;
			}
			
			fixed4 frag (v2f i) : SV_Target
			{
				return i.col;
			}
			ENDCG
		}
	}
}
```

## 3.2 顶点片元着色器实现水波

```c#
Shader "Unlit/10.25" //定义一个名为"Unlit/10.25"的Shader
{
	Properties //定义Shader的属性
	{
		_MainTex("_MainTex",2D)="white"{} //定义一个2D纹理属性，名为"_MainTex"，默认值为白色
		_Color("Color",color)=(1,1,1,1) //定义一个颜色属性，名为"_Color"，默认值为白色

		_XSpeed("XSpeed",range(0,1))=0 //定义一个范围在0到1之间的浮点数属性，名为"_XSpeed"，默认值为0
		_YSpeed("YSpeed",range(0,1))=0 //定义一个范围在0到1之间的浮点数属性，名为"_YSpeed"，默认值为0
	}
	SubShader //定义子着色器
	{
		Tags { "RenderType"="Opaque" } //设置渲染类型为不透明
		LOD 100 //设置细节等级为100

		Pass //定义一个渲染通道
		{
			CGPROGRAM //开始编写CG程序
			#pragma vertex vert //指定顶点着色器函数为vert
			#pragma fragment frag //指定片元着色器函数为frag
			
			#include "UnityCG.cginc" //包含Unity的CG库

			sampler2D _MainTex; //纹理采样器
			float4 _MainTex_ST; //纹理变换参数
			fixed4 _Color; //颜色参数
			fixed _XSpeed; //X方向速度参数
			fixed _YSpeed; //Y方向速度参数

			struct v2f //定义顶点到片元的数据结构体
			{
				float4 vertex:SV_POSITION; //裁剪空间中的顶点位置
				float2 uv:TEXCOORD0; //纹理坐标
			};

			
			v2f vert (appdata_base v) //顶点着色器函数
			{
				v2f o;
				v.vertex.y+=0.2*sin((v.vertex.x+v.vertex.z)+_Time.y); //修改顶点的y坐标，实现顶点动画效果
				o.vertex = UnityObjectToClipPos(v.vertex); //将顶点位置从对象空间转换到裁剪空间
				o.uv=TRANSFORM_TEX(v.texcoord,_MainTex); //进行纹理坐标变换
				return o;
			}
			
			fixed4 frag (v2f i) : SV_Target //片元着色器函数
			{
				float2 uv=i.uv;
				uv+=float2(_XSpeed,_YSpeed)*_Time.y; //修改UV坐标，实现纹理滚动效果
				return _Color*tex2D(_MainTex,uv); //采样纹理并乘以颜色值，得到最终的颜色结果
			}
			ENDCG //结束CG程序编写
		}
	}
}

```

# 四、颜色混合的原理

## 1.正片叠底

即两个颜色的色值相乘。由于黑色色值是（0，0，0，0），白色色值是（1，1，1，1）。

因此黑色和任何颜色混合都是黑色
（1,1,1,1）*（0,0,0,0）=（0,0,0,0）
白色和任何其他颜色混合都得其他颜色
(1,1,1,1)*(0.5,0.5,0.5,0.5)=(0.5,0.5,0.5,0.5)


## 2.线性叠加

用于将两个或多个颜色值相加以产生最终的颜色值。线性叠加的计算方式是将每个颜色通道（如红色、绿色和蓝色）的值相加，当颜色叠加的值超过1时会产生发光效果

```c#
Shader "Unlit/10.25"
{
	Properties
	{
		_MainTex("_MainTex",2D)="white"{}
	}
	SubShader
	{
		Tags { "RenderType"="Opaque" }

		Pass
		{
			CGPROGRAM
			#pragma vertex vert
			#pragma fragment frag
			
			#include "UnityCG.cginc"

			sampler2D _MainTex;
			float4 _MainTex_ST;

			struct v2f
			{
				float4 vertex:SV_POSITION;
				float2 uv:TEXCOORD0;
			};

			
			v2f vert (appdata_base v)
			{
				v2f o;
				o.vertex = UnityObjectToClipPos(v.vertex);
				o.uv=TRANSFORM_TEX(v.texcoord,_MainTex);
				return o;
			}
			
			fixed4 frag (v2f i) : SV_Target
			{
				float l=cos(_Time.y*10)+2;
				return tex2D(_MainTex,i.uv)*l;
			}
			ENDCG
		}
	}
}

```