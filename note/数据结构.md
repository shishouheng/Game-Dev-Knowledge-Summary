# 一、定义

数据结构是研究数据如何在程序中进行组织的一种方式，处理他们相互之间的某种特定关系


数据元素之间的具体关系有以下几种：

- 集合关系：数据元素之间唯一的关系就是同属于一个集合，无序且唯一
- 线性结构关系：数据元素之间有着一对一的关系
- 树形结构关系：数据元素之间有着一对多的关系
- 图状结构关系：数据元素之间有着多对多的关系


c#开发过程中常用的数据结构有以下
- 数组Array
- 动态数组ArrayList
- 泛型动态数组List
- 双向链表LinkedList
- 栈Stack
- 队列Queue
- 字典Dictionary


# 二、线性表

线性表是一种逻辑结构，表示除第一个元素外每个元素都有一个前驱元素，以及除了最后一个元素外每个元素都有一个后继元素，数据元素之间存在一对一的关系。

而顺序表和链表虽然都是线性表，但他们是物理意义上存储结构不同的线性表

## 2.1 顺序表

**用一组地址连续的存储单元依次存储线性表的数据元素，这种存储结构的线性表叫做顺序表，其特点是逻辑上相邻的数据元素在物理次序上也是相邻的**
###  数组

数组是一种最简单的顺序表，使用连续的内存空间来存储元素。数组具有固定的大小，可以通过索引直接访问元素。数组的插入和删除操作比较费时，因为需要移动其他元素来保持连续性


## 2.2 链表

**在链表中除了要存储数据元素的信息外，还要存储它的后继元素的地址，因此逻辑上相邻的数据元素在物理次序上不一定是相邻的，链式存储有三种，分别是：单向链表、双向链表和环形链表**


### 单向链表

链表的链接方向是单向的，对链表的访问必须按顺序从头开始

```c#
public class ListNode
{
    //节点存储的元素值
    public int value;
    public ListNode (int newValue)
    {
        value = newValue;
    }

    //上一项
    public ListNode front;
    //下一项
    public ListNode next;
}

/// <summary>
/// 单向链表
/// </summary>
public class LinkList
{
    //头节点
    private ListNode headNode;
    //尾节点
    private ListNode tailNode;
    //链表长度
    private int listCount;
    //当前节点
    private ListNode current;

    public LinkList ()
    {
        headNode = null;
        tailNode = null;
        listCount = 0;
    }

    public void MoveFirst()
    {
        current = headNode;
    }

    public void MoveLast()
    {
        current = tailNode;
    }

    public void MoveNext()
    {
        if (current.next != null)
            current = current.next;
    }

    public bool IsNull()
    {
        if (listCount == 0)
            return true;
        return false;
    }

    public void Append(int data)
    {
        ListNode newNode = new ListNode(data);
        if (IsNull())
        {
            headNode = newNode;
            tailNode = newNode;
        }
        else
        {
            tailNode.next = newNode;
            tailNode = newNode;
        }
        current = newNode;
        listCount++;
    }

    public void Insert(int data)
    {
        ListNode newNode = new ListNode(data);
        if(IsNull())
        {
            Append(data);
            return;
        }

        //往头节点插
        if(current==headNode)
        {
            newNode.next = headNode;
            headNode = newNode;
            listCount++;
            return;
        }

        //往中间插
        newNode.next = current;
        ListNode temp = headNode;
        while(temp.next!=current)
        {
            temp = temp.next;
        }
        temp.next = newNode;
        current = newNode;
        listCount++;
    }

    public void Show()
    {
        ListNode temp = headNode;
        while(temp!=null)
        {
            Debug.Log(temp.value);
            temp = temp.next;
        }
    }

    public void Remove()
    {
        if (IsNull())
            return;

        if(current==headNode)
        {
            headNode = headNode.next;
            if (headNode == null)
                tailNode = null;
            current = headNode;
            listCount--;
            return;
        }

        if(current==tailNode)
        {
            ListNode temp1 = headNode;
            while (temp1.next != current)
                temp1 = temp1.next;
            temp1.next = null;
            tailNode = temp1;
            current = tailNode;
            listCount--;
            return;
        }

        //移除中间节点
        ListNode temp = headNode;
        while (temp.next != current)
            temp = temp.next;
        temp.next = current.next;
        current = current.next;
        listCount--;
    }
}
```


### 双向链表

在单链表的每个节点中，再设置一个指向其前驱节点的指针，即双向链表中一个指向其前驱元素一个指向其后继元素

C#实现双向链表

```c#

//链表节点类
public class ListNode
{
    //节点存储的元素值
    public int value;
    public ListNode (int newValue)
    {
        value = newValue;
    }

    //上一项
    public ListNode front;
    //下一项
    public ListNode next;
}

public class LinkList 
{
    //头节点
    private ListNode headNode;
    //尾节点
    private ListNode tailNode;
    //链表长度
    private int listCount;
    //当前节点
    private  ListNode current;

    public LinkList()
    {
        headNode = null;
        tailNode = null;
        listCount = 0;
    }

    public void MoveFirst()
    {
        current = headNode;
    }

    public void MoveLast()
    {
        current = tailNode;
    }

    public void MoveNext()
    {
        if (current.next != null)
            current = current.next;
    }

    public bool IsNull()
    {
        if (listCount == 0)
            return true;
        return false;
    }

    //往双向链表添加新元素
    public void Append(int data)
    {
        ListNode newNode = new ListNode(data);
        if (IsNull())
        {
            headNode = newNode;
            tailNode = newNode;
        }
        else
        {
            tailNode.next = newNode;
            newNode.front = tailNode;
            tailNode = newNode;
        }
        current = newNode;
        listCount++;
    }

    //往双向链表插入新元素
    public void Insert(int data)
    {
        ListNode newNode = new ListNode(data);
        if (IsNull())
        {
            Append(data);
            return;
        }
        //往头节点插入
        if (current == headNode)
        {
            newNode.next = headNode;
            headNode.front = newNode;
            headNode = newNode;
            current = headNode;
            listCount++;
            return;
        }

        //往中间插入
        newNode.next = current;
        newNode.front = current.front;

        current.front.next = newNode;
        current.front = newNode;

        current = newNode;
        listCount++;
    }

    public void Show(bool forward)
    {
        if(forward)
        {
            ListNode temp = headNode;
            while(temp!=null)
            {
                Debug.Log(temp.value);
                temp = temp.next;
            }
        }
        else
        {
            ListNode temp = tailNode;
            while(temp!=null)
            {
                Debug.Log(temp.value);
                temp = temp.front;
            }
        }
    }

    public void Remove()
    {
        if (IsNull())
            return;

        if(current==headNode)
        {
            headNode = headNode.next;
            current = headNode;
            current.front = null;
            listCount--;
            return;
        }

        if(current==tailNode)
        {
            tailNode = tailNode.front;
            current = tailNode;
            tailNode.next = null;
            listCount--;
            return;
        }

        current.front.next = current.next;
        current.next.front = current.front;
        current = current.front;
        listCount--;
    }
}

```

### 环形链表

最后一个节点指向头节点形成一个环，从链表中任何一个节点触发都能找到其他节点

c#实现环形链表
```c#
public class ListNode
{
    //节点存储的元素值
    public int value;
    public ListNode(int newValue)
    {
        value = newValue;
    }

    //上一项
    public ListNode front;
    //下一项
    public ListNode next;
}

/// <summary>
/// 环形链表
/// </summary>
public class CircleLinkList
{
    private ListNode headNode;
    private ListNode tailNode;
    private int listCount;
    private ListNode current;

    public CircleLinkList()
    {
        headNode = null;
        tailNode = null;
        listCount = 0;

    }

    public void MoveFirst()
    {
        current = headNode;
    }

    public void MoveLast()
    {
        current = tailNode;
    }

    public bool IsNull()
    {
        if (listCount == 0)
            return true;
        return false;
    }

    public void Append(int data)
    {
        ListNode newNode = new ListNode(data);
        if (IsNull())
        {
            headNode = newNode;
            tailNode = newNode;
            newNode.next = headNode;
        }


        else
        {
            tailNode.next = newNode;
            tailNode = newNode;
            newNode.next = headNode;
        }

        current = newNode;
        listCount++;
    }

    public void Insert(int data)
    {
        ListNode newNode = new ListNode(data);
        if(IsNull())
        {
            Append(data);
            return;
        }

        //往头节点插入
        if(current==headNode)
        {
            newNode.next = headNode;
            headNode = newNode;
            tailNode.next = headNode;
            listCount++;
            return;
        }

        //中间插入
        newNode.next = current;
        ListNode temp = headNode;
        while (temp.next != current)
            temp = temp.next;
        temp.next = newNode;
        current = newNode;
        listCount++;
    }

    public void Show()
    {
        ListNode temp = headNode;
        do
        {
            Debug.Log(temp.value);
            temp = temp.next;
        }
        while (temp != headNode);
    }

    public void Remove()
    {
        if (IsNull())
            return;

        if(current==headNode)
        {
            headNode = headNode.next;
            if (headNode == null)
                tailNode = null;
            current = headNode;
            listCount--;
            return;
        }

        if(current==tailNode)
        {
            ListNode temp1 = headNode;
            while (temp1.next != current)
                temp1 = temp1.next;
            temp1.next = headNode;
            tailNode = temp1;
            current = tailNode;
            listCount--;
            return;
        }

        //移除中间节点
        ListNode temp = headNode;
        while (temp.next != current)
            temp = temp.next;
        temp.next = current.next;
        current = current.next;
        listCount--;

    }
}
```
## 2.3 栈


## 2.4 队列




# 三、二叉树

## 3.1  二叉树定义

二叉树是一种每个节点最多有两个子树的树形结构，并且二叉树的子树有左右之分，次序不能任意颠倒


## 3.2 满二叉树和完全二叉树

- **满二叉树：** 一颗深度为k且拥有2^k-1个节点的树称为满二叉树。从图形上看即除了叶子节点以外的所有节点均有两个子树，节点数达到最大值，并且叶子节点都在同一层，这样的树就是满二叉树
- **完全二叉树：** 一颗深度为k的二叉树，除了k层以外，其他各层的节点数都达到最大值，并且第k层的所有节点都连续集中在左边


## 3.3 二叉树的遍历方式

二叉树有四种遍历方式

- 先序遍历（根左右）
    先访问根节点
    访问左节点
    访问右节点

- 中序遍历（左根右）
    先访问左节点
    访问根节点
    访问右节点

- 后序遍历（左右根）
    先访问左节点
    访问右节点
    访问根节点

- 层次遍历
    从根开始从左往右依次遍历


## 3.4 c#实现二叉树

```c#
//二叉树节点类
public class TreeNode <T> where T: IComparable
{
    public T data;

    //左子树右子树
    public TreeNode<T> leftChild;
    public TreeNode<T> rightChild;

    public TreeNode(T data,TreeNode<T> l,TreeNode<T>r)
    {
        this.data = data;
        this.leftChild = l;
        this.rightChild = r;
    }

    public TreeNode(T data)
    {
        this.data = data;
    }

    //插入
    public void Insert(TreeNode<T> other)
    {
        if(data.CompareTo(other.data)>0)
        {
            if (leftChild == null)
                leftChild = other;
            else
                leftChild.Insert(other);
        }
        else
        {
            if (rightChild == null)
                rightChild = other;
            else
                rightChild.Insert(other);
        }
    }

    //前序遍历
    public void PreorderNode()
    {
        Debug.Log(data);

        if (leftChild != null)
            leftChild.PreorderNode();

        if (rightChild != null)
            rightChild.PreorderNode();
    }

    //中序遍历
    public void InorderNode()
    {
        if (leftChild != null)
            leftChild.InorderNode();

        Debug.Log(data);

        if (rightChild != null)
            rightChild.InorderNode();
    }

    //后序遍历
    public void PostorderNode()
    {
        if (leftChild != null)
            leftChild.PostorderNode();

        if (rightChild != null)
            rightChild.PostorderNode();

        Debug.Log(data);
    }
}
```

```c#
//二叉树类
class BinaryTree<T> where T : IComparable
{
    //二叉树根节点
    private TreeNode<T> head;

    public BinaryTree(TreeNode<T> head)
    {
        this.head = head;
    }

    public BinaryTree() { }

    public void Insert(T data)
    {
        if (head == null)
        {
            head = new TreeNode<T>(data);
            return;
        }

        TreeNode<T> temp = new TreeNode<T>(data);
        head.Insert(temp);
    }

    public void PreorderNode()
    {
        if (head == null)
            return;
        head.PreorderNode();
    }

    public void InorderNode()
    {
        if (head == null)
            return;
        head.InorderNode();
    }

    public void PostorderNode()
    {
        if (head == null)
            return;
        head.PostorderNode();
    }

    //层次遍历
    public void LevelorderNode()
    {
        if (head == null)
            return;

        List<TreeNode<T>> datas = new List<TreeNode<T>>();
        datas.Add(head);

        while (datas.Count > 0)
        {
            Debug.Log(datas[0].data);

            if (datas[0].leftChild != null)
                datas.Add(datas[0].leftChild);

            if (datas[0].rightChild != null)
                datas.Add(datas[0].rightChild);

            datas.Remove(datas[0]);
        }
    }

    //树的深度
    public int Height(TreeNode<T> root)
    {
        if (root == null)
            return 0;

        return 1 + Mathf.Max(Height(root.leftChild), Height(root.rightChild));
    }
}
```











